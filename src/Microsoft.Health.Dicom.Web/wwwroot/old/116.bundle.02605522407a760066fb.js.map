{"version":3,"file":"116.bundle.02605522407a760066fb.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleRadius.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolatePoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/calculateAreaOfPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getIntersectionWithPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js","webpack:///../../../node_modules/d3-interpolate/src/quantize.js","webpack:///../../../node_modules/d3-array/src/transpose.js","webpack:///../../../node_modules/d3-array/src/zip.js","webpack:///../../../node_modules/d3-array/src/min.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js","webpack:///../../../node_modules/d3-interpolate/src/basis.js"],"sourcesContent":["import drawLine from './drawLine';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n}\n//# sourceMappingURL=drawArrow.js.map","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nfunction drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const w = Math.abs(corner1[0] - corner2[0]);\n    const h = Math.abs(corner1[1] - corner2[1]);\n    const xMin = Math.min(corner1[0], corner2[0]);\n    const yMin = Math.min(corner1[1], corner2[1]);\n    const center = [xMin + w / 2, yMin + h / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        _setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        _setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipse;\n//# sourceMappingURL=drawEllipse.js.map","import _getHash from './_getHash';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nexport default function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {\n    if (points.length < 2) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n        connectLastToFirst: false,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (const point of points) {\n        pointsAttribute += `${point[0]}, ${point[1]} `;\n    }\n    if (options.connectLastToFirst) {\n        const firstPoint = points[0];\n        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n    }\n    const attributes = {\n        points: pointsAttribute,\n        stroke: color,\n        fill: 'none',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingPolyLine) {\n        _setAttributesIfNecessary(attributes, existingPolyLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newPolyLine = document.createElementNS(svgns, 'polyline');\n        _setNewAttributesIfValid(attributes, newPolyLine);\n        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n    }\n}\n//# sourceMappingURL=drawPolyline.js.map","import { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass AngleTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId]) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const textLines = this._getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _getTextLines(data, targetId) {\n        const cachedVolumeStats = data.cachedStats[targetId];\n        const { angle } = cachedVolumeStats;\n        if (angle === undefined) {\n            return;\n        }\n        const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n        return textLines;\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId } = enabledElement;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            cachedStats[targetId] = {\n                angle,\n            };\n        }\n        annotation.invalidated = false;\n        const eventType = Events.ANNOTATION_MODIFIED;\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return cachedStats;\n    }\n}\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n//# sourceMappingURL=AngleTool.js.map","import { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass ArrowAnnotateTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const { arrowFirst } = this.configuration;\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    text: '',\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        arrowFirst,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { viewportId, renderingEngineId, renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((text) => {\n                    if (!text) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.text = text;\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                });\n            }\n            else {\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportId,\n                    renderingEngineId,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, text } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!text) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const { renderingEngine, viewportId, renderingEngineId } = getEnabledElement(element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        const eventType = Events.ANNOTATION_MODIFIED;\n        triggerEvent(eventTarget, eventType, {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        });\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n//# sourceMappingURL=ArrowAnnotateTool.js.map","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit === undefined) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const textLines = this._getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._getTextLines = (data, targetId) => {\n            const { cachedStats } = data;\n            const { length, width, unit } = cachedStats[targetId];\n            if (length === undefined) {\n                return;\n            }\n            const textLines = [\n                `L: ${length.toFixed(2)} ${unit}`,\n                `W: ${width.toFixed(2)} ${unit}`,\n            ];\n            return textLines;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportId, renderingEngineId } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions, hasPixelSpacing } = image;\n                const dist1 = this._calculateLength(worldPos1, worldPos2);\n                const dist2 = this._calculateLength(worldPos3, worldPos4);\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit: hasPixelSpacing ? 'mm' : 'px',\n                };\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        return annotation;\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n//# sourceMappingURL=BidirectionalTool.js.map","import { distanceToPoint } from '../point';\nexport default function getCanvasCircleRadius(circleCanvasPoints) {\n    const [center, end] = circleCanvasPoints;\n    return distanceToPoint(center, end);\n}\n//# sourceMappingURL=getCanvasCircleRadius.js.map","import { distanceToPoint } from '../point';\nexport default function getCanvasCircleCorners(circleCanvasPoints) {\n    const [center, end] = circleCanvasPoints;\n    const radius = distanceToPoint(center, end);\n    const topLeft = [center[0] - radius, center[1] - radius];\n    const bottomRight = [center[0] + radius, center[1] + radius];\n    return [topLeft, bottomRight];\n}\n//# sourceMappingURL=getCanvasCircleCorners.js.map","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, eventTarget, triggerEvent, utilities as csUtils, } from '@cornerstonejs/core';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            centerPointRadius: 0,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const radius = getCanvasCircleRadius(canvasCoordinates);\n            const radiusPoint = getCanvasCircleRadius([\n                canvasCoordinates[0],\n                canvasCoords,\n            ]);\n            if (Math.abs(radiusPoint - radius) < proximity / 2)\n                return true;\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                data.handles.points[0],\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0) {\n                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n                const canvasCenter = currentCanvasPoints;\n                const canvasEnd = [\n                    canvasCoordinates[1][0] + dXCanvas,\n                    canvasCoordinates[1][1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasCenter);\n                points[1] = canvasToWorld(canvasEnd);\n            }\n            else {\n                points[1] = canvasToWorld(currentCanvasPoints);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit === undefined) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const isPreScaled = isViewportPreScaled(viewport, targetId);\n                const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n                const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getTextLines = (data, targetId, isPreScaled, isSuvScaled) => {\n            const cachedVolumeStats = data.cachedStats[targetId];\n            const { radius, radiusUnit, area, mean, stdDev, max, isEmptyArea, Modality, areaUnit, } = cachedVolumeStats;\n            const textLines = [];\n            const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n            if (radius) {\n                const radiusLine = isEmptyArea\n                    ? `Radius: Oblique not supported`\n                    : `Radius: ${radius.toFixed(2)} ${radiusUnit}`;\n                textLines.push(radiusLine);\n            }\n            if (area) {\n                const areaLine = isEmptyArea\n                    ? `Area: Oblique not supported`\n                    : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n                textLines.push(areaLine);\n            }\n            if (mean) {\n                textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n            }\n            if (max) {\n                textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n            }\n            if (stdDev) {\n                textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n            }\n            return textLines;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { viewportId, renderingEngineId } = enabledElement;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n                const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const ellipseObj = {\n                        center,\n                        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2));\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    let max = -Infinity;\n                    const meanMaxCalculator = ({ value: newValue }) => {\n                        if (newValue > max) {\n                            max = newValue;\n                        }\n                        mean += newValue;\n                        count += 1;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), meanMaxCalculator, boundsIJK);\n                    mean /= count;\n                    const stdCalculator = ({ value }) => {\n                        const valueMinusMean = value - mean;\n                        stdDev += valueMinusMean * valueMinusMean;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), stdCalculator, boundsIJK);\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        max,\n                        stdDev,\n                        isEmptyArea,\n                        areaUnit: hasPixelSpacing ? 'mm' : 'px',\n                        radius: worldWidth / 2,\n                        radiusUnit: hasPixelSpacing ? 'mm' : 'px',\n                        perimeter: 2 * Math.PI * (worldWidth / 2),\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n}\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n//# sourceMappingURL=CircleROITool.js.map","const midPoint = (...args) => {\n    const ret = args[0].length === 2 ? [0, 0] : [0, 0, 0];\n    const len = args.length;\n    for (const arg of args) {\n        ret[0] += arg[0] / len;\n        ret[1] += arg[1] / len;\n        if (ret.length === 3)\n            ret[2] += arg[2] / len;\n    }\n    return ret;\n};\nconst midPoint2 = midPoint;\nexport default midPoint;\nexport { midPoint2 };\n//# sourceMappingURL=midPoint.js.map","import { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass CobbAngleTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3, point4] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId]) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = '3';\n                const mid1 = midPoint2(canvasCoordinates[0], canvasCoordinates[1]);\n                const mid2 = midPoint2(canvasCoordinates[2], canvasCoordinates[3]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const textLines = this._getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _getTextLines(data, targetId) {\n        const cachedVolumeStats = data.cachedStats[targetId];\n        const { angle } = cachedVolumeStats;\n        if (angle === undefined) {\n            return;\n        }\n        const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n        return textLines;\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId } = enabledElement;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const worldPos4 = data.handles.points[3];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos3, worldPos4]);\n            cachedStats[targetId] = {\n                angle,\n            };\n        }\n        annotation.invalidated = false;\n        const eventType = Events.ANNOTATION_MODIFIED;\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return cachedStats;\n    }\n}\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n//# sourceMappingURL=CobbAngleTool.js.map","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, eventTarget, triggerEvent, utilities as csUtils, } from '@cornerstonejs/core';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawCircle as drawCircleSvg, drawEllipse as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            centerPointRadius: 0,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    initialRotation: viewport.getRotation(),\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerCanvas: canvasPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n            const [canvasPoint1, canvasPoint2] = canvasCorners;\n            const minorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n            };\n            const majorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas } = enabledElement.viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerCanvas,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld } = enabledElement.viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerCanvas, originalHandleCanvas, } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const rotation = Math.abs(viewport.getRotation() - (data.initialRotation || 0));\n                let canvasCorners;\n                if (rotation == 90 || rotation == 270) {\n                    canvasCorners = getCanvasEllipseCorners([\n                        canvasCoordinates[2],\n                        canvasCoordinates[3],\n                        canvasCoordinates[0],\n                        canvasCoordinates[1],\n                    ]);\n                }\n                else {\n                    canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                }\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit === undefined) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCorners[0], canvasCorners[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const isPreScaled = isViewportPreScaled(viewport, targetId);\n                const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n                const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getTextLines = (data, targetId, isPreScaled, isSuvScaled) => {\n            const cachedVolumeStats = data.cachedStats[targetId];\n            const { area, mean, stdDev, max, isEmptyArea, Modality, areaUnit } = cachedVolumeStats;\n            const textLines = [];\n            const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n            if (area) {\n                const areaLine = isEmptyArea\n                    ? `Area: Oblique not supported`\n                    : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n                textLines.push(areaLine);\n            }\n            if (mean) {\n                textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n            }\n            if (max) {\n                textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n            }\n            if (stdDev) {\n                textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n            }\n            return textLines;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { viewportId, renderingEngineId } = enabledElement;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n                const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const ellipseObj = {\n                        center,\n                        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2));\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    let max = -Infinity;\n                    const meanMaxCalculator = ({ value: newValue }) => {\n                        if (newValue > max) {\n                            max = newValue;\n                        }\n                        mean += newValue;\n                        count += 1;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), meanMaxCalculator, boundsIJK);\n                    mean /= count;\n                    const stdCalculator = ({ value }) => {\n                        const valueMinusMean = value - mean;\n                        stdDev += valueMinusMean * valueMinusMean;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), stdCalculator, boundsIJK);\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        max,\n                        stdDev,\n                        isEmptyArea,\n                        areaUnit: hasPixelSpacing ? 'mm' : 'px',\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    _pointInEllipseCanvas(ellipse, location) {\n        const xRadius = ellipse.width / 2;\n        const yRadius = ellipse.height / 2;\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n        const normalized = [location[0] - center[0], location[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n//# sourceMappingURL=EllipticalROITool.js.map","import { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit === undefined) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const textLines = this._getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _getTextLines(data, targetId) {\n        const cachedVolumeStats = data.cachedStats[targetId];\n        const { length, unit } = cachedVolumeStats;\n        if (length === undefined || length === null || isNaN(length)) {\n            return;\n        }\n        const textLines = [`${length.toFixed(2)} ${unit}`];\n        return textLines;\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId } = enabledElement;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetIdImage(targetId, renderingEngine);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions, hasPixelSpacing } = image;\n            const length = this._calculateLength(worldPos1, worldPos2);\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            this._isInsideVolume(index1, index2, dimensions)\n                ? (this.isHandleOutsideImage = false)\n                : (this.isHandleOutsideImage = true);\n            cachedStats[targetId] = {\n                length,\n                unit: hasPixelSpacing ? 'mm' : 'px',\n            };\n        }\n        annotation.invalidated = false;\n        const eventType = Events.ANNOTATION_MODIFIED;\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n//# sourceMappingURL=LengthTool.js.map","import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldInterpolate(configuration) {\n    return (configuration?.interpolation?.interpolateOnAdd === true ||\n        configuration?.interpolation?.interpolateOnEdit === true);\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, interpolateOnAdd = false, interpolateOnEdit = false, } = interpolation;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? interpolateOnEdit : interpolateOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=interpolatePoints.js.map","import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n//# sourceMappingURL=findOpenUShapedContourVectorToPeak.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { Events } from '../../../enums';\nimport { state } from '../../../store';\nimport { vec3 } from 'gl-matrix';\nimport { shouldInterpolate, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstIntersectionWithPolyline, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints } = this.drawData;\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n    }\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element);\n    }\n    else {\n        this.completeDrawClosedContour(element);\n    }\n}\nfunction completeDrawClosedContour(element) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldInterpolate(this.configuration)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = false;\n    this.triggerAnnotationCompleted(annotation);\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstIntersectionWithPolyline(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n    }\n}\nfunction completeDrawOpenContour(element) {\n    const { canvasPoints } = this.drawData;\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldInterpolate(this.configuration)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    this.triggerAnnotationCompleted(annotation);\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstIntersectionWithPolyline(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    for (let i = 0; i < crossingIndex; i++) {\n        canvasPoints.shift();\n    }\n    if (this.completeDrawClosedContour(element)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element);\n    }\n    else {\n        this.completeDrawClosedContour(element);\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n//# sourceMappingURL=drawLoop.js.map","import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstIntersectionWithPolyline } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstIntersectionWithPolyline(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstIntersectionWithPolyline(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstIntersectionWithPolyline(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstIntersectionWithPolyline(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstIntersectionWithPolyline(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstIntersectionWithPolyline(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstIntersectionWithPolyline(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n//# sourceMappingURL=editLoopCommon.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { getInterpolatedPoints, shouldInterpolate, } from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, calculateAreaOfPoints, } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    const worldPoints = fusedCanvasPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = false;\n    this.triggerAnnotationModified(annotation, enabledElement);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n    };\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = calculateAreaOfPoints(pointSet1);\n    const areaPointSet2 = calculateAreaOfPoints(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldInterpolate(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n        annotation.data.polyline = worldPoints;\n        annotation.data.isOpenContour = false;\n        this.triggerAnnotationModified(annotation, enabledElement);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n//# sourceMappingURL=closedContourEditLoop.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport { shouldInterpolate, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    const worldPoints = fusedCanvasPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    this.triggerAnnotationModified(annotation, enabledElement);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    const worldPoints = fusedCanvasPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    this.triggerAnnotationModified(annotation, enabledElement);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldInterpolate(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n        annotation.data.polyline = worldPoints;\n        annotation.data.isOpenContour = true;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        this.triggerAnnotationModified(annotation, enabledElement);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n//# sourceMappingURL=openContourEditLoop.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n//# sourceMappingURL=openContourEndEditLoop.js.map","import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const isOpenContour = annotation.data.isOpenContour;\n    const options = {\n        color: color === undefined ? undefined : color,\n        width: lineWidth === undefined ? undefined : lineWidth,\n        lineDash: lineDash === undefined ? undefined : lineDash,\n        connectLastToFirst: !isOpenContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.isOpenContour) {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n    else {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { polyline, openUShapeContourVectorToPeak } = annotation.data;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        connectLastToFirst: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        connectLastToFirst: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.connectLastToFirst = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n//# sourceMappingURL=renderMethods.js.map","import { CONSTANTS, getEnabledElement, triggerEvent, eventTarget, StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getIntersectionCoordinatesWithPolyline } from '../../utilities/math/polyline/getIntersectionWithPolyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            subPixelResolution: 4,\n            interpolation: {\n                interpolateOnAdd: false,\n                interpolateOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            calculateStats: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        points: [],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    polyline: [[...worldPos]],\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.isOpenContour) {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const points = annotation.data.polyline;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const distance = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (distance === true) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (annotation.data.isOpenContour) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            const distance = pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n            if (distance === true) {\n                return true;\n            }\n            return false;\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationCompleted = (annotation) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const targetId = this.getTargetId(viewport);\n            let annotations = (getAnnotations(this.getToolName(), element));\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n                annotations.forEach((annotation) => {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                });\n            }\n            else {\n                const activeAnnotationUID = this.commonData.annotation.annotationUID;\n                annotations.forEach((annotation) => {\n                    if (annotation.annotationUID === activeAnnotationUID) {\n                        if (isDrawing) {\n                            this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                        }\n                        else if (isEditingClosed) {\n                            this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                        }\n                        else if (isEditingOpen) {\n                            this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                        }\n                        else {\n                            throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                        }\n                    }\n                    else {\n                        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                    }\n                });\n                renderStatus = true;\n            }\n            if (!this.configuration.calculateStats)\n                return;\n            annotations.forEach((annotation) => {\n                const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n                if (annotation.annotationUID === activeAnnotationUID &&\n                    !this.commonData?.movingTextBox)\n                    return;\n                if (!this.commonData?.movingTextBox) {\n                    const { data } = annotation;\n                    if (!data.cachedStats[targetId] ||\n                        data.cachedStats[targetId].areaUnit === undefined) {\n                        data.cachedStats[targetId] = {\n                            Modality: null,\n                            area: null,\n                            max: null,\n                            mean: null,\n                            stdDev: null,\n                            areaUnit: null,\n                        };\n                        this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    }\n                    else if (annotation.invalidated) {\n                        this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    }\n                }\n                this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n            });\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { cachedStats, polyline: points } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata, hasPixelSpacing } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const area = polyline.calculateAreaOfPoints(canvasCoordinates);\n                const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n                worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n                worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n                worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n                let iMin = worldPosIndex[0];\n                let iMax = worldPosIndex[0];\n                let jMin = worldPosIndex[1];\n                let jMax = worldPosIndex[1];\n                let kMin = worldPosIndex[2];\n                let kMax = worldPosIndex[2];\n                for (let j = 1; j < points.length; j++) {\n                    const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n                    worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n                    worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n                    worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n                    iMin = Math.min(iMin, worldPosIndex[0]);\n                    iMax = Math.max(iMax, worldPosIndex[0]);\n                    jMin = Math.min(jMin, worldPosIndex[1]);\n                    jMax = Math.max(jMax, worldPosIndex[1]);\n                    kMin = Math.min(kMin, worldPosIndex[2]);\n                    kMax = Math.max(kMax, worldPosIndex[2]);\n                }\n                const iDelta = 0.01 * (iMax - iMin);\n                const jDelta = 0.01 * (jMax - jMin);\n                const kDelta = 0.01 * (kMax - kMin);\n                iMin = Math.floor(iMin - iDelta);\n                iMax = Math.ceil(iMax + iDelta);\n                jMin = Math.floor(jMin - jDelta);\n                jMax = Math.ceil(jMax + jDelta);\n                kMin = Math.floor(kMin - kDelta);\n                kMax = Math.ceil(kMax + kDelta);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n                const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n                let count = 0;\n                let sum = 0;\n                let sumSquares = 0;\n                let max = -Infinity;\n                const statCalculator = ({ value: newValue }) => {\n                    if (newValue > max) {\n                        max = newValue;\n                    }\n                    sum += newValue;\n                    sumSquares += newValue ** 2;\n                    count += 1;\n                };\n                let curRow = 0;\n                let intersections = [];\n                let intersectionCounter = 0;\n                pointInShapeCallback(imageData, (pointLPS, pointIJK) => {\n                    let result = true;\n                    const point = viewport.worldToCanvas(pointLPS);\n                    if (point[1] != curRow) {\n                        intersectionCounter = 0;\n                        curRow = point[1];\n                        intersections = getIntersectionCoordinatesWithPolyline(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                        intersections.sort((function (index) {\n                            return function (a, b) {\n                                return a[index] === b[index]\n                                    ? 0\n                                    : a[index] < b[index]\n                                        ? -1\n                                        : 1;\n                            };\n                        })(0));\n                    }\n                    if (intersections.length && point[0] > intersections[0][0]) {\n                        intersections.shift();\n                        intersectionCounter++;\n                    }\n                    if (intersectionCounter % 2 === 0) {\n                        result = false;\n                    }\n                    return result;\n                }, statCalculator, boundsIJK);\n                const mean = sum / count;\n                let stdDev = sumSquares / count - mean ** 2;\n                stdDev = Math.sqrt(stdDev);\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    mean,\n                    max,\n                    stdDev,\n                    areaUnit: hasPixelSpacing ? 'mm' : 'px',\n                };\n            }\n            annotation.invalidated = false;\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            const isPreScaled = isViewportPreScaled(viewport, targetId);\n            const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n            const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n            if (!textLines || textLines.length === 0)\n                return;\n            const canvasCoordinates = data.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this._getTextLines = (data, targetId, isPreScaled, isSuvScaled) => {\n            const cachedVolumeStats = data.cachedStats[targetId];\n            const { area, mean, stdDev, max, isEmptyArea, Modality, areaUnit } = cachedVolumeStats;\n            const textLines = [];\n            const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n            if (area) {\n                const areaLine = isEmptyArea\n                    ? `Area: Oblique not supported`\n                    : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n                textLines.push(areaLine);\n            }\n            if (mean) {\n                textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n            }\n            if (max) {\n                textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n            }\n            if (stdDev) {\n                textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n            }\n            return textLines;\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof StackViewport) {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n        }\n        else {\n            throw new Error(`Viewport Type ${viewport.type} not supported`);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n}\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n//# sourceMappingURL=PlanarFreehandROITool.js.map","import { vec3 } from 'gl-matrix';\nexport default function angleBetweenLines(line1, line2) {\n    const [p1, p2] = line1;\n    const [p3, p4] = line2;\n    const v1 = vec3.sub(vec3.create(), p2, p1);\n    const v2 = vec3.sub(vec3.create(), p3, p4);\n    const dot = vec3.dot(v1, v2);\n    const v1Length = vec3.length(v1);\n    const v2Length = vec3.length(v2);\n    const cos = dot / (v1Length * v2Length);\n    const radian = Math.acos(cos);\n    return (radian * 180) / Math.PI;\n}\n//# sourceMappingURL=angleBetweenLines.js.map","function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return;\n    }\n    const denom = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denom;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denom;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n//# sourceMappingURL=intersectLine.js.map","export default function distanceToPoint(p1, p2) {\n    if (p1?.length !== 2 || p2?.length !== 2) {\n        throw Error('points should have 2 elements of [x, y]');\n    }\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n//# sourceMappingURL=distanceToPoint.js.map","export default function calculateAreaOfPoints(points) {\n    const n = points.length;\n    let area = 0.0;\n    let j = n - 1;\n    for (let i = 0; i < n; i++) {\n        area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n        j = i;\n    }\n    return Math.abs(area / 2.0);\n}\n//# sourceMappingURL=calculateAreaOfPoints.js.map","import { vec2 } from 'gl-matrix';\nfunction getAllIntersectionsWithPolyline(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    const intersections = [];\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (doesIntersect(p1, q1, p2, q2)) {\n            intersections.push([j, i]);\n        }\n        j = i;\n    }\n    return intersections;\n}\nfunction getIntersectionCoordinatesWithPolyline(points, p1, q1, closed = true) {\n    const result = [];\n    const polylineIndexes = getAllIntersectionsWithPolyline(points, p1, q1, closed);\n    for (let i = 0; i < polylineIndexes.length; i++) {\n        const p2 = points[polylineIndexes[i][0]];\n        const q2 = points[polylineIndexes[i][1]];\n        const intersection = getIntersection(p1, q1, p2, q2);\n        result.push(intersection);\n    }\n    return result;\n}\nfunction getFirstIntersectionWithPolyline(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (doesIntersect(p1, q1, p2, q2)) {\n            return [j, i];\n        }\n        j = i;\n    }\n}\nfunction getClosestIntersectionWithPolyline(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    const intersections = [];\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (doesIntersect(p1, q1, p2, q2)) {\n            intersections.push([j, i]);\n        }\n        j = i;\n    }\n    if (intersections.length === 0) {\n        return;\n    }\n    const distances = [];\n    intersections.forEach((intersection) => {\n        const intersectionPoints = [\n            points[intersection[0]],\n            points[intersection[1]],\n        ];\n        const midpoint = [\n            (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n            (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n        ];\n        distances.push(vec2.distance(midpoint, p1));\n    });\n    const minDistance = Math.min(...distances);\n    const indexOfMinDistance = distances.indexOf(minDistance);\n    return {\n        segment: intersections[indexOfMinDistance],\n        distance: minDistance,\n    };\n}\nfunction doesIntersect(p1, q1, p2, q2) {\n    let result = false;\n    const orient = [\n        orientation(p1, q1, p2),\n        orientation(p1, q1, q2),\n        orientation(p2, q2, p1),\n        orientation(p2, q2, q1),\n    ];\n    if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n        return true;\n    }\n    if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n        result = true;\n    }\n    else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n        result = true;\n    }\n    else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n        result = true;\n    }\n    else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n        result = true;\n    }\n    return result;\n}\nfunction orientation(p, q, r) {\n    const orientationValue = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    if (orientationValue === 0) {\n        return 0;\n    }\n    return orientationValue > 0 ? 1 : 2;\n}\nfunction onSegment(p, q, r) {\n    if (q[0] <= Math.max(p[0], r[0]) &&\n        q[0] >= Math.min(p[0], r[0]) &&\n        q[1] <= Math.max(p[1], r[1]) &&\n        q[1] >= Math.min(p[1], r[1])) {\n        return true;\n    }\n    return false;\n}\nfunction getIntersection(p1, q1, p2, q2) {\n    const denominator = (q2[1] - p2[1]) * (q1[0] - p1[0]) - (q2[0] - p2[0]) * (q1[1] - p1[1]);\n    if (denominator == 0) {\n        return;\n    }\n    let a = p1[1] - p2[1];\n    let b = p1[0] - p2[0];\n    const numerator1 = (q2[0] - p2[0]) * a - (q2[1] - p2[1]) * b;\n    const numerator2 = (q1[0] - p1[0]) * a - (q1[1] - p1[1]) * b;\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n    const resultX = p1[0] + a * (q1[0] - p1[0]);\n    const resultY = p1[1] + a * (q1[1] - p1[1]);\n    return [resultX, resultY];\n}\nexport { getAllIntersectionsWithPolyline, getFirstIntersectionWithPolyline, getClosestIntersectionWithPolyline, getIntersectionCoordinatesWithPolyline, };\n//# sourceMappingURL=getIntersectionWithPolyline.js.map","import { StackViewport } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst EPSILON = 1e-3;\nconst getSubPixelSpacingAndXYDirections = (viewport, subPixelResolution) => {\n    let spacing;\n    let xDir;\n    let yDir;\n    if (viewport instanceof StackViewport) {\n        const imageData = viewport.getImageData();\n        xDir = imageData.direction.slice(0, 3);\n        yDir = imageData.direction.slice(3, 6);\n        spacing = imageData.spacing;\n    }\n    else {\n        const imageData = viewport.getImageData();\n        const { direction, spacing: volumeSpacing } = imageData;\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const iVector = direction.slice(0, 3);\n        const jVector = direction.slice(3, 6);\n        const kVector = direction.slice(6, 9);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n        const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n        const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n        let xSpacing;\n        if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n            xSpacing = volumeSpacing[0];\n            xDir = iVector;\n        }\n        else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n            xSpacing = volumeSpacing[1];\n            xDir = jVector;\n        }\n        else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n            xSpacing = volumeSpacing[2];\n            xDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n        const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n        const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n        let ySpacing;\n        if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n            ySpacing = volumeSpacing[0];\n            yDir = iVector;\n        }\n        else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n            ySpacing = volumeSpacing[1];\n            yDir = jVector;\n        }\n        else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n            ySpacing = volumeSpacing[2];\n            yDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        spacing = [xSpacing, ySpacing];\n    }\n    const subPixelSpacing = [\n        spacing[0] / subPixelResolution,\n        spacing[1] / subPixelResolution,\n    ];\n    return { spacing: subPixelSpacing, xDir, yDir };\n};\nexport default getSubPixelSpacingAndXYDirections;\n//# sourceMappingURL=getSubPixelSpacingAndXYDirections.js.map","import { vec2 } from 'gl-matrix';\nconst pointsAreWithinCloseContourProximity = (p1, p2, closeContourProximity) => {\n    return vec2.dist(p1, p2) < closeContourProximity;\n};\nexport default pointsAreWithinCloseContourProximity;\n//# sourceMappingURL=pointsAreWithinCloseContourProximity.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nconst addCanvasPointsToArray = (element, canvasPoints, newCanvasPoint, commonData) => {\n    const { xDir, yDir, spacing } = commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const lastWorldPos = viewport.canvasToWorld(canvasPoints[canvasPoints.length - 1]);\n    const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    const numPointsToAdd = Math.max(Math.floor(xDist / spacing[0]), Math.floor(yDist / spacing[0]));\n    if (numPointsToAdd > 1) {\n        const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n        const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n        const canvasDir = vec2.create();\n        vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n        vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n        const distPerPoint = canvasDist / numPointsToAdd;\n        for (let i = 1; i <= numPointsToAdd; i++) {\n            canvasPoints.push([\n                lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n                lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n            ]);\n        }\n    }\n    else {\n        canvasPoints.push(newCanvasPoint);\n    }\n    return numPointsToAdd;\n};\nexport default addCanvasPointsToArray;\n//# sourceMappingURL=addCanvasPointsToArray.js.map","import { vec2 } from 'gl-matrix';\nconst pointCanProjectOnLine = (p, p1, p2, proximity) => {\n    const p1p = [p[0] - p1[0], p[1] - p1[1]];\n    const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n    const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n    if (dot < 0) {\n        return false;\n    }\n    const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n    if (p1p2Mag === 0) {\n        return false;\n    }\n    const projectionVectorMag = dot / p1p2Mag;\n    const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n    const projectionVector = [\n        p1p2UnitVector[0] * projectionVectorMag,\n        p1p2UnitVector[1] * projectionVectorMag,\n    ];\n    const projectionPoint = [\n        p1[0] + projectionVector[0],\n        p1[1] + projectionVector[1],\n    ];\n    const distance = vec2.distance(p, projectionPoint);\n    if (distance > proximity) {\n        return false;\n    }\n    if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n        return false;\n    }\n    return true;\n};\nexport default pointCanProjectOnLine;\n//# sourceMappingURL=pointCanProjectOnLine.js.map","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","import min from \"./min.js\";\n\nexport default function transpose(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","import { interpolatePoints } from './algorithms/bspline';\nfunction getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {\n    const result = [];\n    const [intervalIni, intervalEnd] = closedInterval;\n    const intervalSize = intervalEnd - intervalIni + 1;\n    const intensity = Math.floor(intervalSize / minDistributionDistance);\n    let x = 0;\n    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    while (continuosDistributionValue <= intervalEnd) {\n        result.push(continuosDistributionValue);\n        x++;\n        continuosDistributionValue =\n            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    }\n    return result;\n}\nexport default function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {\n    const segmentSize = endIndex - iniIndex + 1;\n    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n        return points;\n    }\n    if (segmentSize / minKnotDistance < 2) {\n        return points;\n    }\n    const interpolationIniIndex = Math.max(0, iniIndex);\n    const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);\n    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n        interpolationIniIndex,\n        interpolationEndIndex,\n    ]);\n    const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n    return [\n        ...segmentPointsUnchangedBeg,\n        ...interpolatedPoints,\n        ...segmentPointsUnchangedEnd,\n    ];\n}\n//# sourceMappingURL=interpolateSegmentPoints.js.map","import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n//# sourceMappingURL=bspline.js.map","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n//# sourceMappingURL=getWorldWidthAndHeightFromTwoPoints.js.map","export function basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nexport default function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n"],"names":["drawArrow","svgDrawingHelper","annotationUID","arrowUID","start","end","options","isNaN","color","width","lineWidth","lineDash","Object","assign","undefined","angle","Math","atan2","firstLine","cos","PI","sin","secondLine","ellipseUID","corner1","corner2","dataId","strokeWidth","svgNodeHash","existingEllipse","getSvgNode","w","abs","h","center","min","attributes","cx","cy","rx","ry","stroke","fill","setNodeTouched","svgEllipseElement","document","createElementNS","setAttribute","appendNode","drawPolyline","polylineUID","points","length","connectLastToFirst","existingPolyLine","pointsAttribute","point","firstPoint","newPolyLine","AngleTool","constructor","toolProps","defaultToolProps","supportedInteractionTypes","configuration","shadow","preventHandleOutsideImage","super","this","addNewAnnotation","evt","angleStartedNotYetCompleted","eventDetail","detail","currentPoints","element","worldPos","world","enabledElement","viewport","renderingEngine","hideElementCursor","isDrawing","camera","getCamera","viewPlaneNormal","viewUp","referencedImageId","getReferencedImageId","FrameOfReferenceUID","getFrameOfReferenceUID","annotation","highlighted","invalidated","metadata","toolName","getToolName","data","handles","activeHandleIndex","textBox","hasMoved","worldPosition","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","cachedStats","addAnnotation","viewportIdsToRender","editData","handleIndex","movingTextBox","newAnnotation","_activateDraw","preventDefault","isPointNearTool","canvasCoords","proximity","point1","point2","point3","canvasPoint1","worldToCanvas","canvasPoint2","canvasPoint3","line1","x","y","line2","distanceToPoint","distanceToPoint2","toolSelectedCallback","_activateModify","_endCallback","_deactivateModify","_deactivateDraw","resetElementCursor","isHandleOutsideImage","removeAnnotation","eventType","_dragCallback","deltaPoints","worldPosDelta","forEach","cancel","addEventListener","removeEventListener","renderAnnotation","renderStatus","annotations","getAnnotations","filterInteractableAnnotationsForElement","targetId","getTargetId","getRenderingEngine","styleSpecifier","toolGroupId","viewportId","id","i","getStyle","canvasCoordinates","map","p","activeHandleCanvasCoords","_throttledCalculateCachedStats","_calculateCachedStats","isAnnotationLocked","console","warn","handleGroupUID","lineUID","textLines","_getTextLines","canvasTextBoxCoords","canvasToWorld","textBoxPosition","textBoxUID","boundingBox","getLinkedTextBoxStyle","left","top","height","trailing","handleSelectedCallback","handle","findIndex","cachedVolumeStats","toFixed","String","fromCharCode","renderingEngineId","worldPos1","worldPos2","worldPos3","targetIds","keys","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","text","line","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","find","canvas","_doneChangingTextCallback","bind","stopImmediatePropagation","updatedText","_isInsideVolume","index1","index2","dimensions","doneChangingTextCallback","prompt","eventData","transformWorldToIndex","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","_dragDrawCallback","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","sqrt","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyCallback","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","unit","isAnnotationVisible","dataId1","dataId2","secondLineUID","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","image","getTargetIdImage","imageData","hasPixelSpacing","dist1","_calculateLength","dist2","index3","index4","vector1","vector2","pos1","pos2","dz","getCanvasCircleRadius","circleCanvasPoints","getCanvasCircleCorners","radius","CircleROITool","AnnotationTool","centerPointRadius","getEnabledElement","getViewportIdsWithToolToRender","triggerAnnotationRenderForViewportIds","radiusPoint","Events","triggerEvent","eventTarget","currentCanvasPoints","_dragHandle","dXCanvas","dYCanvas","canvasCenter","canvasEnd","state","canvasCorners","areaUnit","VolumeViewport","startsWith","getStackViewports","vp","referencedImageURI","hasImageURI","currentImageURI","getCurrentImageId","Modality","area","max","mean","stdDev","radiusUnit","perimeter","drawHandles","circleUID","drawCircle","isPreScaled","isViewportPreScaled","isSuvScaled","getTextBoxCoordsCanvas","drawLinkedTextBox","isEmptyArea","getModalityUnit","radiusLine","push","areaLine","topLeftCanvas","bottomRightCanvas","topLeftWorld","bottomRightWorld","worldPos1Index","floor","worldPos2Index","boundsIJK","ellipseObj","xRadius","yRadius","zRadius","worldWidth","worldHeight","getWorldWidthAndHeightFromTwoPoints","count","Infinity","meanMaxCalculator","value","newValue","pointInShapeCallback","pointLPS","pointIJK","pointInEllipse","stdCalculator","valueMinusMean","throttle","midPoint","args","ret","len","arg","midPoint2","CobbAngleTool","point4","canvasPoint4","interactionType","_mouseUpCallback","_mouseDragCallback","drawLine","mid1","mid2","angleBetweenLines","EllipticalROITool","canvasPos","initialRotation","getRotation","centerCanvas","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","canvasBottom","canvasTop","newHalfCanvasWidth","canvasLeft","canvasRight","newHalfCanvasHeight","rotation","centerPoint","_getCanvasEllipseCenter","ellipse","location","normalized","ellipseCanvasPoints","bottom","right","LengthTool","shouldInterpolate","interpolation","interpolateOnAdd","interpolateOnEdit","followingIndex","index","size","direction","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","startIndex","otherStartIndex","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","j","pointA","pointB","findMatchIndexes","toBeNotEqualCriteria","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","highIndex","getInterpolatedPoints","pointsOfReference","result","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","knotsRatioPercentage","changedIniIndex","changedEndIndex","interpolateSegmentPoints","findOpenUShapedContourVectorToPeak","canvasPoints","first","last","firstToLastUnitVector","vec2","normalVector1","normalVector2","centerOfFirstToLast","furthest","dist","canvasPoint","distance","addCanvasPointsToArray","pointsAreWithinCloseContourProximity","getFirstIntersectionWithPolyline","getSubPixelSpacingAndXYDirections","polyline","activateDraw","spacing","xDir","yDir","subPixelResolution","drawData","polylineIndex","commonData","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","lastCanvasPoint","lastWorldPoint","worldPosDiff","vec3","create","subtract","xDist","dot","yDist","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","allowOpenContours","lastPoint","closeContourProximity","completeDrawOpenContour","completeDrawClosedContour","removeCrossedLinesOnCompleteDraw","haltDrawing","pop","worldPoints","isOpenContour","triggerAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","slice","lineSegment","indexToRemoveUpTo","splice","isOpenUShapeContour","openUShapeContourVectorToPeak","lastPoints","pointsLessLastOne","shift","activateClosedContourEdit","cancelDrawing","minPoints","shouldHaltDrawing","toolInstance","checkForFirstCrossing","isClosedContour","editCanvasPoints","prevCanvasPoints","crossedLineSegment","startCrossingIndex","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","sort","a","b","twoClosestDistanceIndexPairs","lowestIndex","dir","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","unshift","editIndex","numPointsToRemove","checkForSecondCrossing","removePointsAfterSecondCrossing","lastLine","didCrossLine","findSnapIndex","lastEditCanvasPoint","editCanvasPointsLessLastOne","snapCanvasPosition","checkAndRemoveCrossesOnEditLine","editIndexCrossed","isEditingClosed","mouseUpClosedContourEditCallback","mouseDragClosedContourEditCallback","deactivateClosedContourEdit","currentEditIndex","snapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","finishEditAndStartNewEdit","triggerAnnotationModified","augmentedEditCanvasPoints","lowIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","cancelClosedContourEdit","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activateOpenContourEndEdit","lastCanvasPos","p1","p2","p3","aDotb","magA","magB","acos","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","reverse","_getRenderingOptions","renderContour","getImageData","findOpenUShapedContourVectorToPeakOnRender","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","renderClosedContour","alwaysRenderOpenContourHandles","enabled","handlePoints","handleRadius","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","pointCanProjectOnLine","EPSILON","PARALLEL_THRESHOLD","PlanarFreehandROITool","calculateStats","previousPoint","pStart","pEnd","activeAnnotationUID","Error","_renderStats","worldPosIndex","iMin","iMax","jMin","jMax","kMin","kMax","iDelta","jDelta","kDelta","ceil","worldPosEnd","indexToWorld","canvasPosEnd","sum","sumSquares","statCalculator","curRow","intersections","intersectionCounter","annotationsToDisplay","StackViewport","filterAnnotationsForDisplay","type","spacingInNormalDirection","filterAnnotationsWithinSlice","annotationsWithParallelNormals","filter","td","annotationViewPlaneNormal","isParallel","halfSpacingInNormalDirection","focalPoint","annotationsWithinSlice","isVisible","sub","p4","v1","v2","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","pow","calculateAreaOfPoints","n","getIntersectionCoordinatesWithPolyline","q1","closed","polylineIndexes","initialI","doesIntersect","getAllIntersectionsWithPolyline","intersection","getIntersection","getClosestIntersectionWithPolyline","q2","distances","intersectionPoints","midpoint","minDistance","segment","indexOf","orient","orientation","onSegment","q","r","orientationValue","denominator","numerator1","numerator2","volumeSpacing","iVector","jVector","kVector","viewRight","cross","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","newCanvasPoint","lastWorldPos","newWorldPos","numPointsToAdd","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","interpolator","samples","Array","d","zip","matrix","m","values","valueof","transpose","row","arguments","iniIndex","endIndex","segmentSize","amountOfKnots","minKnotDistance","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","interpolatedPoints","originalPoints","knotsIndexes","xInterpolator","k","yInterpolator","zInterpolator","interpolatePoints","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","intensity","continuosDistributionValue","round","getContinuousUniformDistributionValues","diagonal","diagonalLength","cosTheta","basis","t1","v0","v3","t2","t3","t"],"sourceRoot":""}