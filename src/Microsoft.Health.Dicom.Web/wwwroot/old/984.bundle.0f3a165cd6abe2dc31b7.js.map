{"version":3,"file":"984.bundle.0f3a165cd6abe2dc31b7.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/id.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/constants/scoordTypes.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/DICOMSRDisplayTool.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/toolNames.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addMeasurement.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/isRehydratable.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getFilteredCornerstoneToolState.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/commandsModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addToolInstance.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/createReferencedImageDisplaySet.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/onModeEnter.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/init.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/modules/dicomSRModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/hydrateStructuredReport.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getLabelFromDCMJSImportedToolData.js"],"sourcesContent":["import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\n\r\nconst SOPClassHandlerName = 'dicom-sr';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nexport { SOPClassHandlerName, SOPClassHandlerId, id };\r\n","export default {\r\n  POINT: 'POINT',\r\n  MULTIPOINT: 'MULTIPOINT',\r\n  POLYLINE: 'POLYLINE',\r\n  CIRCLE: 'CIRCLE',\r\n  ELLIPSE: 'ELLIPSE',\r\n};\r\n","import { Types, metaData, utilities as csUtils } from '@cornerstonejs/core';\r\nimport {\r\n  AnnotationTool,\r\n  annotation,\r\n  drawing,\r\n  utilities,\r\n  Types as cs3DToolsTypes,\r\n} from '@cornerstonejs/tools';\r\nimport { getTrackingUniqueIdentifiersForElement } from './modules/dicomSRModule';\r\nimport SCOORD_TYPES from '../constants/scoordTypes';\r\n\r\nexport default class DICOMSRDisplayTool extends AnnotationTool {\r\n  static toolName = 'DICOMSRDisplay';\r\n\r\n  constructor(\r\n    toolProps = {},\r\n    defaultToolProps = {\r\n      configuration: {},\r\n    }\r\n  ) {\r\n    super(toolProps, defaultToolProps);\r\n  }\r\n\r\n  _getTextBoxLinesFromLabels(labels) {\r\n    // TODO -> max 3 for now (label + shortAxis + longAxis), need a generic solution for this!\r\n\r\n    const labelLength = Math.min(labels.length, 3);\r\n    const lines = [];\r\n\r\n    for (let i = 0; i < labelLength; i++) {\r\n      const labelEntry = labels[i];\r\n      lines.push(`${_labelToShorthand(labelEntry.label)}${labelEntry.value}`);\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  // This tool should not inherit from AnnotationTool and we should not need\r\n  // to add the following lines.\r\n  isPointNearTool = () => null;\r\n  getHandleNearImagePoint = () => null;\r\n\r\n  renderAnnotation = (\r\n    enabledElement: Types.IEnabledElement,\r\n    svgDrawingHelper: any\r\n  ): void => {\r\n    const { viewport } = enabledElement;\r\n    const { element } = viewport;\r\n\r\n    let annotations = annotation.state.getAnnotations(\r\n      this.getToolName(),\r\n      element\r\n    );\r\n\r\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    annotations = this.filterInteractableAnnotationsForElement(\r\n      element,\r\n      annotations\r\n    );\r\n\r\n    if (!annotations?.length) {\r\n      return;\r\n    }\r\n\r\n    const trackingUniqueIdentifiersForElement = getTrackingUniqueIdentifiersForElement(\r\n      element\r\n    );\r\n\r\n    const {\r\n      activeIndex,\r\n      trackingUniqueIdentifiers,\r\n    } = trackingUniqueIdentifiersForElement;\r\n\r\n    const activeTrackingUniqueIdentifier =\r\n      trackingUniqueIdentifiers[activeIndex];\r\n\r\n    // Filter toolData to only render the data for the active SR.\r\n    const filteredAnnotations = annotations.filter(annotation =>\r\n      trackingUniqueIdentifiers.includes(\r\n        annotation.data?.cachedStats?.TrackingUniqueIdentifier\r\n      )\r\n    );\r\n\r\n    if (!viewport._actors?.size) {\r\n      return;\r\n    }\r\n\r\n    const styleSpecifier: cs3DToolsTypes.AnnotationStyle.StyleSpecifier = {\r\n      toolGroupId: this.toolGroupId,\r\n      toolName: this.getToolName(),\r\n      viewportId: enabledElement.viewport.id,\r\n    };\r\n\r\n    for (let i = 0; i < filteredAnnotations.length; i++) {\r\n      const annotation = filteredAnnotations[i];\r\n      const annotationUID = annotation.annotationUID;\r\n      const { renderableData } = annotation.data.cachedStats;\r\n      const { cachedStats } = annotation.data;\r\n      const { referencedImageId } = annotation.metadata;\r\n\r\n      styleSpecifier.annotationUID = annotationUID;\r\n\r\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\r\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\r\n      const color =\r\n        cachedStats.TrackingUniqueIdentifier === activeTrackingUniqueIdentifier\r\n          ? 'rgb(0, 255, 0)'\r\n          : this.getStyle('color', styleSpecifier, annotation);\r\n\r\n      const options = {\r\n        color,\r\n        lineDash,\r\n        lineWidth,\r\n      };\r\n\r\n      Object.keys(renderableData).forEach(GraphicType => {\r\n        const renderableDataForGraphicType = renderableData[GraphicType];\r\n\r\n        let renderMethod;\r\n        let canvasCoordinatesAdapter;\r\n\r\n        switch (GraphicType) {\r\n          case SCOORD_TYPES.POINT:\r\n            renderMethod = this.renderPoint;\r\n            break;\r\n          case SCOORD_TYPES.MULTIPOINT:\r\n            renderMethod = this.renderMultipoint;\r\n            break;\r\n          case SCOORD_TYPES.POLYLINE:\r\n            renderMethod = this.renderPolyLine;\r\n            break;\r\n          case SCOORD_TYPES.CIRCLE:\r\n            renderMethod = this.renderEllipse;\r\n            break;\r\n          case SCOORD_TYPES.ELLIPSE:\r\n            renderMethod = this.renderEllipse;\r\n            canvasCoordinatesAdapter =\r\n              utilities.math.ellipse.getCanvasEllipseCorners;\r\n            break;\r\n          default:\r\n            throw new Error(`Unsupported GraphicType: ${GraphicType}`);\r\n        }\r\n\r\n        const canvasCoordinates = renderMethod(\r\n          svgDrawingHelper,\r\n          viewport,\r\n          renderableDataForGraphicType,\r\n          annotationUID,\r\n          referencedImageId,\r\n          options\r\n        );\r\n\r\n        this.renderTextBox(\r\n          svgDrawingHelper,\r\n          viewport,\r\n          canvasCoordinates,\r\n          canvasCoordinatesAdapter,\r\n          annotation,\r\n          styleSpecifier,\r\n          options\r\n        );\r\n      });\r\n    }\r\n  };\r\n\r\n  renderPolyLine(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    const drawingOptions = {\r\n      color: options.color,\r\n      width: options.lineWidth,\r\n    };\r\n    let allCanvasCoordinates = [];\r\n    renderableData.map((data, index) => {\r\n      const canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\r\n      const lineUID = `${index}`;\r\n\r\n      if (canvasCoordinates.length === 2) {\r\n        drawing.drawLine(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          canvasCoordinates[0],\r\n          canvasCoordinates[1],\r\n          drawingOptions\r\n        );\r\n      } else {\r\n        drawing.drawPolyline(\r\n          svgDrawingHelper,\r\n          annotationUID,\r\n          lineUID,\r\n          canvasCoordinates,\r\n          drawingOptions\r\n        );\r\n      }\r\n\r\n      allCanvasCoordinates = allCanvasCoordinates.concat(canvasCoordinates);\r\n    });\r\n\r\n    return allCanvasCoordinates; // used for drawing textBox\r\n  }\r\n\r\n  renderMultipoint(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    let canvasCoordinates;\r\n    renderableData.map((data, index) => {\r\n      canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\r\n      const handleGroupUID = '0';\r\n      drawing.drawHandles(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        handleGroupUID,\r\n        canvasCoordinates,\r\n        {\r\n          color: options.color,\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  renderPoint(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    const canvasCoordinates = [];\r\n    renderableData.map((data, index) => {\r\n      const point = data[0];\r\n      // This gives us one point for arrow\r\n      canvasCoordinates.push(viewport.worldToCanvas(point));\r\n\r\n      // We get the other point for the arrow by using the image size\r\n      const imagePixelModule = metaData.get(\r\n        'imagePixelModule',\r\n        referencedImageId\r\n      );\r\n\r\n      let xOffset = 10;\r\n      let yOffset = 10;\r\n\r\n      if (imagePixelModule) {\r\n        const { columns, rows } = imagePixelModule;\r\n        xOffset = columns / 10;\r\n        yOffset = rows / 10;\r\n      }\r\n\r\n      const imagePoint = csUtils.worldToImageCoords(referencedImageId, point);\r\n      const arrowEnd = csUtils.imageToWorldCoords(referencedImageId, [\r\n        imagePoint[0] + xOffset,\r\n        imagePoint[1] + yOffset,\r\n      ]);\r\n\r\n      canvasCoordinates.push(viewport.worldToCanvas(arrowEnd));\r\n\r\n      const arrowUID = `${index}`;\r\n\r\n      // Todo: handle drawing probe as probe, currently we are drawing it as an arrow\r\n      drawing.drawArrow(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        arrowUID,\r\n        canvasCoordinates[1],\r\n        canvasCoordinates[0],\r\n        {\r\n          color: options.color,\r\n          width: options.lineWidth,\r\n        }\r\n      );\r\n    });\r\n\r\n    return canvasCoordinates; // used for drawing textBox\r\n  }\r\n\r\n  renderEllipse(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    renderableData,\r\n    annotationUID,\r\n    referencedImageId,\r\n    options\r\n  ) {\r\n    let canvasCoordinates;\r\n    renderableData.map((data, index) => {\r\n      if (data.length === 0) {\r\n        // since oblique ellipse is not supported for hydration right now\r\n        // we just return\r\n        return;\r\n      }\r\n\r\n      const ellipsePointsWorld = data;\r\n\r\n      const rotation = viewport.getRotation();\r\n\r\n      canvasCoordinates = ellipsePointsWorld.map(p =>\r\n        viewport.worldToCanvas(p)\r\n      );\r\n      let canvasCorners;\r\n      if (rotation == 90 || rotation == 270) {\r\n        canvasCorners = <Array<Types.Point2>>(\r\n          utilities.math.ellipse.getCanvasEllipseCorners([\r\n            canvasCoordinates[2],\r\n            canvasCoordinates[3],\r\n            canvasCoordinates[0],\r\n            canvasCoordinates[1],\r\n          ])\r\n        );\r\n      } else {\r\n        canvasCorners = <Array<Types.Point2>>(\r\n          utilities.math.ellipse.getCanvasEllipseCorners(canvasCoordinates)\r\n        );\r\n      }\r\n\r\n      const lineUID = `${index}`;\r\n      drawing.drawEllipse(\r\n        svgDrawingHelper,\r\n        annotationUID,\r\n        lineUID,\r\n        canvasCorners[0],\r\n        canvasCorners[1],\r\n        {\r\n          color: options.color,\r\n          width: options.lineWidth,\r\n        }\r\n      );\r\n    });\r\n\r\n    return canvasCoordinates;\r\n  }\r\n\r\n  renderTextBox(\r\n    svgDrawingHelper,\r\n    viewport,\r\n    canvasCoordinates,\r\n    canvasCoordinatesAdapter,\r\n    annotation,\r\n    styleSpecifier,\r\n    options = {}\r\n  ) {\r\n    if (!canvasCoordinates || !annotation) {\r\n      return;\r\n    }\r\n\r\n    const { annotationUID, data = {} } = annotation;\r\n    const { label } = data;\r\n    const { color } = options;\r\n\r\n    let adaptedCanvasCoordinates = canvasCoordinates;\r\n    // adapt coordinates if there is an adapter\r\n    if (typeof canvasCoordinatesAdapter === 'function') {\r\n      adaptedCanvasCoordinates = canvasCoordinatesAdapter(canvasCoordinates);\r\n    }\r\n    const textLines = this._getTextBoxLinesFromLabels(label);\r\n    const canvasTextBoxCoords = utilities.drawing.getTextBoxCoordsCanvas(\r\n      adaptedCanvasCoordinates\r\n    );\r\n\r\n    annotation.data.handles.textBox.worldPosition = viewport.canvasToWorld(\r\n      canvasTextBoxCoords\r\n    );\r\n\r\n    const textBoxPosition = viewport.worldToCanvas(\r\n      annotation.data.handles.textBox.worldPosition\r\n    );\r\n\r\n    const textBoxUID = '1';\r\n    const textBoxOptions = this.getLinkedTextBoxStyle(\r\n      styleSpecifier,\r\n      annotation\r\n    );\r\n\r\n    const boundingBox = drawing.drawLinkedTextBox(\r\n      svgDrawingHelper,\r\n      annotationUID,\r\n      textBoxUID,\r\n      textLines,\r\n      textBoxPosition,\r\n      canvasCoordinates,\r\n      {},\r\n      {\r\n        ...textBoxOptions,\r\n        color,\r\n      }\r\n    );\r\n\r\n    const { x: left, y: top, width, height } = boundingBox;\r\n\r\n    annotation.data.handles.textBox.worldBoundingBox = {\r\n      topLeft: viewport.canvasToWorld([left, top]),\r\n      topRight: viewport.canvasToWorld([left + width, top]),\r\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\r\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\r\n    };\r\n  }\r\n}\r\n\r\nconst SHORT_HAND_MAP = {\r\n  'Short Axis': 'W: ',\r\n  'Long Axis': 'L: ',\r\n  AREA: 'Area: ',\r\n  Length: '',\r\n  CORNERSTONEFREETEXT: '',\r\n};\r\n\r\nfunction _labelToShorthand(label) {\r\n  const shortHand = SHORT_HAND_MAP[label];\r\n\r\n  if (shortHand !== undefined) {\r\n    return shortHand;\r\n  }\r\n\r\n  return label;\r\n}\r\n","import DICOMSRDisplayTool from './DICOMSRDisplayTool';\r\n\r\nconst toolNames = {\r\n  DICOMSRDisplay: DICOMSRDisplayTool.toolName,\r\n  SRLength: 'SRLength',\r\n  SRBidirectional: 'SRBidirectional',\r\n  SREllipticalROI: 'SREllipticalROI',\r\n  SRCircleROI: 'SRCircleROI',\r\n  SRArrowAnnotate: 'SRArrowAnnotate',\r\n  SRAngle: 'SRAngle',\r\n  SRCobbAngle: 'SRCobbAngle',\r\n  SRRectangleROI: 'SRRectangleROI',\r\n  SRPlanarFreehandROI: 'SRPlanarFreehandROI',\r\n};\r\n\r\nexport default toolNames;\r\n","import { vec3 } from 'gl-matrix';\r\nimport { Types, annotation } from '@cornerstonejs/tools';\r\nimport { metaData, utilities, Types as csTypes } from '@cornerstonejs/core';\r\nimport toolNames from '../tools/toolNames';\r\nimport SCOORD_TYPES from '../constants/scoordTypes';\r\n\r\nconst EPSILON = 1e-4;\r\n\r\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\r\n\r\nexport default function addMeasurement(\r\n  measurement,\r\n  imageId,\r\n  displaySetInstanceUID\r\n) {\r\n  // TODO -> Render rotated ellipse .\r\n  const toolName = toolNames.DICOMSRDisplay;\r\n\r\n  const measurementData = {\r\n    TrackingUniqueIdentifier: measurement.TrackingUniqueIdentifier,\r\n    renderableData: {},\r\n    labels: measurement.labels,\r\n    imageId,\r\n  };\r\n\r\n  measurement.coords.forEach(coord => {\r\n    const { GraphicType, GraphicData } = coord;\r\n\r\n    if (measurementData.renderableData[GraphicType] === undefined) {\r\n      measurementData.renderableData[GraphicType] = [];\r\n    }\r\n\r\n    measurementData.renderableData[GraphicType].push(\r\n      _getRenderableData(\r\n        GraphicType,\r\n        GraphicData,\r\n        imageId,\r\n        measurement.TrackingIdentifier\r\n      )\r\n    );\r\n  });\r\n\r\n  // Use the metadata provider to grab its imagePlaneModule metadata\r\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n\r\n  const annotationManager = annotation.state.getAnnotationManager();\r\n\r\n  // Create Cornerstone3D Annotation from measurement\r\n  const frameNumber =\r\n    (measurement.coords[0].ReferencedSOPSequence &&\r\n      measurement.coords[0].ReferencedSOPSequence[0]?.ReferencedFrameNumber) ||\r\n    1;\r\n\r\n  const SRAnnotation: Types.Annotation = {\r\n    annotationUID: measurement.TrackingUniqueIdentifier,\r\n    metadata: {\r\n      FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\r\n      toolName: toolName,\r\n      referencedImageId: imageId,\r\n    },\r\n    data: {\r\n      label: measurement.labels,\r\n      handles: {\r\n        textBox: {},\r\n      },\r\n      cachedStats: {\r\n        TrackingUniqueIdentifier: measurementData.TrackingUniqueIdentifier,\r\n        renderableData: measurementData.renderableData,\r\n      },\r\n      frameNumber: frameNumber,\r\n    },\r\n  };\r\n\r\n  annotationManager.addAnnotation(SRAnnotation);\r\n\r\n  measurement.loaded = true;\r\n  measurement.imageId = imageId;\r\n  measurement.displaySetInstanceUID = displaySetInstanceUID;\r\n\r\n  // Remove the unneeded coord now its processed, but keep the SOPInstanceUID.\r\n  // NOTE: We assume that each SCOORD in the MeasurementGroup maps onto one frame,\r\n  // It'd be super weird if it didn't anyway as a SCOORD.\r\n  measurement.ReferencedSOPInstanceUID =\r\n    measurement.coords[0].ReferencedSOPSequence.ReferencedSOPInstanceUID;\r\n  measurement.frameNumber = frameNumber;\r\n  delete measurement.coords;\r\n}\r\n\r\nfunction _getRenderableData(\r\n  GraphicType,\r\n  GraphicData,\r\n  imageId,\r\n  TrackingIdentifier\r\n) {\r\n  const [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\r\n\r\n  let renderableData: csTypes.Point3[];\r\n\r\n  switch (GraphicType) {\r\n    case SCOORD_TYPES.POINT:\r\n    case SCOORD_TYPES.MULTIPOINT:\r\n    case SCOORD_TYPES.POLYLINE:\r\n      renderableData = [];\r\n\r\n      for (let i = 0; i < GraphicData.length; i += 2) {\r\n        const worldPos = utilities.imageToWorldCoords(imageId, [\r\n          GraphicData[i],\r\n          GraphicData[i + 1],\r\n        ]);\r\n\r\n        renderableData.push(worldPos);\r\n      }\r\n\r\n      break;\r\n    case SCOORD_TYPES.CIRCLE: {\r\n      const pointsWorld = [];\r\n      for (let i = 0; i < GraphicData.length; i += 2) {\r\n        const worldPos = utilities.imageToWorldCoords(imageId, [\r\n          GraphicData[i],\r\n          GraphicData[i + 1],\r\n        ]);\r\n\r\n        pointsWorld.push(worldPos);\r\n      }\r\n\r\n      // We do not have an explicit draw circle svg helper in Cornerstone3D at\r\n      // this time, but we can use the ellipse svg helper to draw a circle, so\r\n      // here we reshape the data for that purpose.\r\n      const center = pointsWorld[0];\r\n      const onPerimeter = pointsWorld[1];\r\n\r\n      const radius = vec3.distance(center, onPerimeter);\r\n\r\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n\r\n      if (!imagePlaneModule) {\r\n        throw new Error('No imagePlaneModule found');\r\n      }\r\n\r\n      const {\r\n        columnCosines,\r\n        rowCosines,\r\n      }: {\r\n        columnCosines: csTypes.Point3;\r\n        rowCosines: csTypes.Point3;\r\n      } = imagePlaneModule;\r\n\r\n      // we need to get major/minor axis (which are both the same size major = minor)\r\n\r\n      // first axisStart\r\n      const firstAxisStart = vec3.create();\r\n      vec3.scaleAndAdd(firstAxisStart, center, columnCosines, radius);\r\n\r\n      const firstAxisEnd = vec3.create();\r\n      vec3.scaleAndAdd(firstAxisEnd, center, columnCosines, -radius);\r\n\r\n      // second axisStart\r\n      const secondAxisStart = vec3.create();\r\n      vec3.scaleAndAdd(secondAxisStart, center, rowCosines, radius);\r\n\r\n      const secondAxisEnd = vec3.create();\r\n      vec3.scaleAndAdd(secondAxisEnd, center, rowCosines, -radius);\r\n\r\n      renderableData = [\r\n        firstAxisStart as csTypes.Point3,\r\n        firstAxisEnd as csTypes.Point3,\r\n        secondAxisStart as csTypes.Point3,\r\n        secondAxisEnd as csTypes.Point3,\r\n      ];\r\n\r\n      break;\r\n    }\r\n    case SCOORD_TYPES.ELLIPSE: {\r\n      // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\r\n      // But Cornerstone3D points are ordered as top, bottom, left, right for the\r\n      // ellipse so we need to identify if the majorAxis is horizontal or vertical\r\n      // and then choose the correct points to use for the ellipse.\r\n\r\n      const pointsWorld: csTypes.Point3[] = [];\r\n      for (let i = 0; i < GraphicData.length; i += 2) {\r\n        const worldPos = utilities.imageToWorldCoords(imageId, [\r\n          GraphicData[i],\r\n          GraphicData[i + 1],\r\n        ]);\r\n\r\n        pointsWorld.push(worldPos);\r\n      }\r\n\r\n      const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\r\n      const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\r\n      const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\r\n      const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\r\n\r\n      const majorAxisVec = vec3.create();\r\n      vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\r\n\r\n      // normalize majorAxisVec to avoid scaling issues\r\n      vec3.normalize(majorAxisVec, majorAxisVec);\r\n\r\n      const minorAxisVec = vec3.create();\r\n      vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\r\n      vec3.normalize(minorAxisVec, minorAxisVec);\r\n\r\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\r\n\r\n      if (!imagePlaneModule) {\r\n        throw new Error('imageId does not have imagePlaneModule metadata');\r\n      }\r\n\r\n      const {\r\n        columnCosines,\r\n      }: { columnCosines: csTypes.Point3 } = imagePlaneModule;\r\n\r\n      // find which axis is parallel to the columnCosines\r\n      const columnCosinesVec = vec3.fromValues(...columnCosines);\r\n\r\n      const projectedMajorAxisOnColVec = Math.abs(\r\n        vec3.dot(columnCosinesVec, majorAxisVec)\r\n      );\r\n      const projectedMinorAxisOnColVec = Math.abs(\r\n        vec3.dot(columnCosinesVec, minorAxisVec)\r\n      );\r\n\r\n      const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\r\n      const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\r\n\r\n      renderableData = [];\r\n      if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\r\n        renderableData = [\r\n          pointsWorld[0],\r\n          pointsWorld[1],\r\n          pointsWorld[2],\r\n          pointsWorld[3],\r\n        ];\r\n      } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\r\n        renderableData = [\r\n          pointsWorld[2],\r\n          pointsWorld[3],\r\n          pointsWorld[0],\r\n          pointsWorld[1],\r\n        ];\r\n      } else {\r\n        console.warn('OBLIQUE ELLIPSE NOT YET SUPPORTED');\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n      console.warn('Unsupported GraphicType:', GraphicType);\r\n  }\r\n\r\n  return renderableData;\r\n}\r\n","import { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nconst cornerstoneAdapters =\r\n  adaptersSR.Cornerstone3D.MeasurementReport\r\n    .CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\r\n\r\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\r\nconst CORNERSTONE_3D_TAG = cornerstoneAdapters.CORNERSTONE_3D_TAG;\r\n\r\n/**\r\n * Checks if the given `displaySet`can be rehydrated into the `measurementService`.\r\n *\r\n * @param {object} displaySet The SR `displaySet` to check.\r\n * @param {object[]} mappings The CornerstoneTools 4 mappings to the `measurementService`.\r\n * @returns {boolean} True if the SR can be rehydrated into the `measurementService`.\r\n */\r\nexport default function isRehydratable(displaySet, mappings) {\r\n  if (!mappings || !mappings.length) {\r\n    return false;\r\n  }\r\n\r\n  const mappingDefinitions = mappings.map(m => m.annotationType);\r\n  const { measurements } = displaySet;\r\n\r\n  const adapterKeys = Object.keys(cornerstoneAdapters).filter(\r\n    adapterKey =>\r\n      typeof cornerstoneAdapters[adapterKey]\r\n        .isValidCornerstoneTrackingIdentifier === 'function'\r\n  );\r\n\r\n  const adapters = [];\r\n\r\n  adapterKeys.forEach(key => {\r\n    if (mappingDefinitions.includes(key)) {\r\n      // Must have both a dcmjs adapter and a measurementService\r\n      // Definition in order to be a candidate for import.\r\n      adapters.push(cornerstoneAdapters[key]);\r\n    }\r\n  });\r\n\r\n  for (let i = 0; i < measurements.length; i++) {\r\n    const { TrackingIdentifier } = measurements[i] || {};\r\n    const hydratable = adapters.some(adapter => {\r\n      let [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\r\n      if (supportedLegacyCornerstoneTags.includes(cornerstoneTag)) {\r\n        cornerstoneTag = CORNERSTONE_3D_TAG;\r\n      }\r\n\r\n      const mappedTrackingIdentifier = `${cornerstoneTag}:${toolName}`;\r\n\r\n      return adapter.isValidCornerstoneTrackingIdentifier(\r\n        mappedTrackingIdentifier\r\n      );\r\n    });\r\n\r\n    if (hydratable) {\r\n      return true;\r\n    }\r\n    console.log(\r\n      'Measurement is not rehydratable',\r\n      TrackingIdentifier,\r\n      measurements[i]\r\n    );\r\n  }\r\n\r\n  console.log('No measurements found which were rehydratable');\r\n  return false;\r\n}\r\n","import { SOPClassHandlerName, SOPClassHandlerId } from './id';\r\nimport { utils, classes, DisplaySetService, Types } from '@ohif/core';\r\nimport addMeasurement from './utils/addMeasurement';\r\nimport isRehydratable from './utils/isRehydratable';\r\nimport { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\ntype InstanceMetadata = Types.InstanceMetadata;\r\n\r\nconst { CodeScheme: Cornerstone3DCodeScheme } = adaptersSR.Cornerstone3D;\r\n\r\nconst { ImageSet, MetadataProvider: metadataProvider } = classes;\r\n\r\n// TODO ->\r\n// Add SR thumbnail\r\n// Make viewport\r\n// Get stacks from referenced displayInstanceUID and load into wrapped CornerStone viewport.\r\n\r\nconst sopClassUids = [\r\n  '1.2.840.10008.5.1.4.1.1.88.11', //BASIC_TEXT_SR:\r\n  '1.2.840.10008.5.1.4.1.1.88.22', //ENHANCED_SR:\r\n  '1.2.840.10008.5.1.4.1.1.88.33', //COMPREHENSIVE_SR:\r\n  '1.2.840.10008.5.1.4.1.1.88.34', //COMPREHENSIVE_3D_SR:\r\n];\r\n\r\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\r\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\r\n\r\nconst validateSameStudyUID = (uid: string, instances): void => {\r\n  instances.forEach(it => {\r\n    if (it.StudyInstanceUID !== uid) {\r\n      console.warn('Not all instances have the same UID', uid, it);\r\n      throw new Error(\r\n        `Instances ${it.SOPInstanceUID} does not belong to ${uid}`\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\nconst CodeNameCodeSequenceValues = {\r\n  ImagingMeasurementReport: '126000',\r\n  ImageLibrary: '111028',\r\n  ImagingMeasurements: '126010',\r\n  MeasurementGroup: '125007',\r\n  ImageLibraryGroup: '126200',\r\n  TrackingUniqueIdentifier: '112040',\r\n  TrackingIdentifier: '112039',\r\n  Finding: '121071',\r\n  FindingSite: 'G-C0E3', // SRT\r\n  CornerstoneFreeText: Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT, //\r\n};\r\n\r\nconst CodingSchemeDesignators = {\r\n  SRT: 'SRT',\r\n  CornerstoneCodeSchemes: [\r\n    Cornerstone3DCodeScheme.CodingSchemeDesignator,\r\n    'CST4',\r\n  ],\r\n};\r\n\r\nconst RELATIONSHIP_TYPE = {\r\n  INFERRED_FROM: 'INFERRED FROM',\r\n  CONTAINS: 'CONTAINS',\r\n};\r\n\r\nconst CORNERSTONE_FREETEXT_CODE_VALUE = 'CORNERSTONEFREETEXT';\r\n\r\n/**\r\n * Adds instances to the DICOM SR series, rather than creating a new\r\n * series, so that as SR's are saved, they append to the series, and the\r\n * key image display set gets updated as well, containing just the new series.\r\n * @param instances is a list of instances from THIS series that are not\r\n *     in this DICOM SR Display Set already.\r\n */\r\nfunction addInstances(\r\n  instances: InstanceMetadata[],\r\n  displaySetService: DisplaySetService\r\n) {\r\n  this.instances.push(...instances);\r\n  utils.sortStudyInstances(this.instances);\r\n  // The last instance is the newest one, so is the one most interesting.\r\n  // Eventually, the SR viewer should have the ability to choose which SR\r\n  // gets loaded, and to navigate among them.\r\n  this.instance = this.instances[this.instances.length - 1];\r\n  this.isLoaded = false;\r\n  return this;\r\n}\r\n\r\n/**\r\n * DICOM SR SOP Class Handler\r\n * For all referenced images in the TID 1500/300 sections, add an image to the\r\n * display.\r\n * @param instances is a set of instances all from the same series\r\n * @param servicesManager is the services that can be used for creating\r\n * @returns The list of display sets created for the given instances object\r\n */\r\nfunction _getDisplaySetsFromSeries(\r\n  instances,\r\n  servicesManager,\r\n  extensionManager\r\n) {\r\n  // If the series has no instances, stop here\r\n  if (!instances || !instances.length) {\r\n    throw new Error('No instances were provided');\r\n  }\r\n\r\n  utils.sortStudyInstances(instances);\r\n  // The last instance is the newest one, so is the one most interesting.\r\n  // Eventually, the SR viewer should have the ability to choose which SR\r\n  // gets loaded, and to navigate among them.\r\n  const instance = instances[instances.length - 1];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    ConceptNameCodeSequence,\r\n    SOPClassUID,\r\n  } = instance;\r\n  validateSameStudyUID(instance.StudyInstanceUID, instances);\r\n\r\n  if (\r\n    !ConceptNameCodeSequence ||\r\n    ConceptNameCodeSequence.CodeValue !==\r\n      CodeNameCodeSequenceValues.ImagingMeasurementReport\r\n  ) {\r\n    servicesManager.services.uiNotificationService.show({\r\n      title: 'DICOM SR',\r\n      message:\r\n        'OHIF only supports TID1500 Imaging Measurement Report Structured Reports. The SR youre trying to view is not supported.',\r\n      type: 'warning',\r\n      duration: 6000,\r\n    });\r\n    return [];\r\n  }\r\n\r\n  const displaySet = {\r\n    //plugin: id,\r\n    Modality: 'SR',\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId,\r\n    SOPClassUID,\r\n    instances,\r\n    referencedImages: null,\r\n    measurements: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    sopClassUids,\r\n    instance,\r\n    addInstances,\r\n  };\r\n\r\n  displaySet.load = () => _load(displaySet, servicesManager, extensionManager);\r\n\r\n  return [displaySet];\r\n}\r\n\r\nfunction _load(displaySet, servicesManager, extensionManager) {\r\n  const { displaySetService, measurementService } = servicesManager.services;\r\n  const dataSources = extensionManager.getDataSources();\r\n  const dataSource = dataSources[0];\r\n\r\n  const { ContentSequence } = displaySet.instance;\r\n\r\n  displaySet.referencedImages = _getReferencedImagesList(ContentSequence);\r\n  displaySet.measurements = _getMeasurements(ContentSequence);\r\n\r\n  const mappings = measurementService.getSourceMappings(\r\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\r\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\r\n  );\r\n\r\n  displaySet.isHydrated = false;\r\n  displaySet.isRehydratable = isRehydratable(displaySet, mappings);\r\n  displaySet.isLoaded = true;\r\n\r\n  // Check currently added displaySets and add measurements if the sources exist.\r\n  displaySetService.activeDisplaySets.forEach(activeDisplaySet => {\r\n    _checkIfCanAddMeasurementsToDisplaySet(\r\n      displaySet,\r\n      activeDisplaySet,\r\n      dataSource\r\n    );\r\n  });\r\n\r\n  // Subscribe to new displaySets as the source may come in after.\r\n  displaySetService.subscribe(\r\n    displaySetService.EVENTS.DISPLAY_SETS_ADDED,\r\n    data => {\r\n      const { displaySetsAdded } = data;\r\n      // If there are still some measurements that have not yet been loaded into cornerstone,\r\n      // See if we can load them onto any of the new displaySets.\r\n      displaySetsAdded.forEach(newDisplaySet => {\r\n        _checkIfCanAddMeasurementsToDisplaySet(\r\n          displaySet,\r\n          newDisplaySet,\r\n          dataSource\r\n        );\r\n      });\r\n    }\r\n  );\r\n}\r\n\r\nfunction _checkIfCanAddMeasurementsToDisplaySet(\r\n  srDisplaySet,\r\n  newDisplaySet,\r\n  dataSource\r\n) {\r\n  let unloadedMeasurements = srDisplaySet.measurements.filter(\r\n    measurement => measurement.loaded === false\r\n  );\r\n\r\n  if (unloadedMeasurements.length === 0) {\r\n    // All already loaded!\r\n    return;\r\n  }\r\n\r\n  if (!newDisplaySet instanceof ImageSet) {\r\n    // This also filters out _this_ displaySet, as it is not an ImageSet.\r\n    return;\r\n  }\r\n\r\n  const { sopClassUids, images } = newDisplaySet;\r\n\r\n  // Check if any have the newDisplaySet is the correct SOPClass.\r\n  unloadedMeasurements = unloadedMeasurements.filter(measurement =>\r\n    measurement.coords.some(coord =>\r\n      sopClassUids.includes(coord.ReferencedSOPSequence.ReferencedSOPClassUID)\r\n    )\r\n  );\r\n\r\n  if (unloadedMeasurements.length === 0) {\r\n    // New displaySet isn't the correct SOPClass, so can't contain the referenced images.\r\n    return;\r\n  }\r\n\r\n  const SOPInstanceUIDs = [];\r\n\r\n  unloadedMeasurements.forEach(measurement => {\r\n    const { coords } = measurement;\r\n\r\n    coords.forEach(coord => {\r\n      const SOPInstanceUID =\r\n        coord.ReferencedSOPSequence.ReferencedSOPInstanceUID;\r\n\r\n      if (!SOPInstanceUIDs.includes(SOPInstanceUID)) {\r\n        SOPInstanceUIDs.push(SOPInstanceUID);\r\n      }\r\n    });\r\n  });\r\n\r\n  const imageIdsForDisplaySet = dataSource.getImageIdsForDisplaySet(\r\n    newDisplaySet\r\n  );\r\n\r\n  for (const imageId of imageIdsForDisplaySet) {\r\n    if (!unloadedMeasurements.length) {\r\n      // All measurements loaded.\r\n      return;\r\n    }\r\n\r\n    const { SOPInstanceUID, frameNumber } = metadataProvider.getUIDsFromImageID(\r\n      imageId\r\n    );\r\n\r\n    if (SOPInstanceUIDs.includes(SOPInstanceUID)) {\r\n      for (let j = unloadedMeasurements.length - 1; j >= 0; j--) {\r\n        const measurement = unloadedMeasurements[j];\r\n        if (\r\n          _measurementReferencesSOPInstanceUID(\r\n            measurement,\r\n            SOPInstanceUID,\r\n            frameNumber\r\n          )\r\n        ) {\r\n          addMeasurement(\r\n            measurement,\r\n            imageId,\r\n            newDisplaySet.displaySetInstanceUID\r\n          );\r\n\r\n          unloadedMeasurements.splice(j, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction _measurementReferencesSOPInstanceUID(\r\n  measurement,\r\n  SOPInstanceUID,\r\n  frameNumber\r\n) {\r\n  const { coords } = measurement;\r\n\r\n  // NOTE: The ReferencedFrameNumber can be multiple values according to the DICOM\r\n  //  Standard. But for now, we will support only one ReferenceFrameNumber.\r\n  const ReferencedFrameNumber =\r\n    (measurement.coords[0].ReferencedSOPSequence &&\r\n      measurement.coords[0].ReferencedSOPSequence[0]?.ReferencedFrameNumber) ||\r\n    1;\r\n\r\n  if (frameNumber && Number(frameNumber) !== Number(ReferencedFrameNumber))\r\n    return false;\r\n\r\n  for (let j = 0; j < coords.length; j++) {\r\n    const coord = coords[j];\r\n    const { ReferencedSOPInstanceUID } = coord.ReferencedSOPSequence;\r\n\r\n    if (ReferencedSOPInstanceUID === SOPInstanceUID) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\r\n  const getDisplaySetsFromSeries = instances => {\r\n    return _getDisplaySetsFromSeries(\r\n      instances,\r\n      servicesManager,\r\n      extensionManager\r\n    );\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: SOPClassHandlerName,\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries,\r\n    },\r\n  ];\r\n}\r\n\r\nfunction _getMeasurements(ImagingMeasurementReportContentSequence) {\r\n  const ImagingMeasurements = ImagingMeasurementReportContentSequence.find(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.ImagingMeasurements\r\n  );\r\n\r\n  const MeasurementGroups = _getSequenceAsArray(\r\n    ImagingMeasurements.ContentSequence\r\n  ).filter(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.MeasurementGroup\r\n  );\r\n\r\n  const mergedContentSequencesByTrackingUniqueIdentifiers = _getMergedContentSequencesByTrackingUniqueIdentifiers(\r\n    MeasurementGroups\r\n  );\r\n\r\n  const measurements = [];\r\n\r\n  Object.keys(mergedContentSequencesByTrackingUniqueIdentifiers).forEach(\r\n    trackingUniqueIdentifier => {\r\n      const mergedContentSequence =\r\n        mergedContentSequencesByTrackingUniqueIdentifiers[\r\n          trackingUniqueIdentifier\r\n        ];\r\n\r\n      const measurement = _processMeasurement(mergedContentSequence);\r\n\r\n      if (measurement) {\r\n        measurements.push(measurement);\r\n      }\r\n    }\r\n  );\r\n\r\n  return measurements;\r\n}\r\n\r\nfunction _getMergedContentSequencesByTrackingUniqueIdentifiers(\r\n  MeasurementGroups\r\n) {\r\n  const mergedContentSequencesByTrackingUniqueIdentifiers = {};\r\n\r\n  MeasurementGroups.forEach(MeasurementGroup => {\r\n    const ContentSequence = _getSequenceAsArray(\r\n      MeasurementGroup.ContentSequence\r\n    );\r\n\r\n    const TrackingUniqueIdentifierItem = ContentSequence.find(\r\n      item =>\r\n        item.ConceptNameCodeSequence.CodeValue ===\r\n        CodeNameCodeSequenceValues.TrackingUniqueIdentifier\r\n    );\r\n\r\n    if (!TrackingUniqueIdentifierItem) {\r\n      console.warn(\r\n        'No Tracking Unique Identifier, skipping ambiguous measurement.'\r\n      );\r\n    }\r\n\r\n    const trackingUniqueIdentifier = TrackingUniqueIdentifierItem.UID;\r\n\r\n    if (\r\n      mergedContentSequencesByTrackingUniqueIdentifiers[\r\n        trackingUniqueIdentifier\r\n      ] === undefined\r\n    ) {\r\n      // Add the full ContentSequence\r\n      mergedContentSequencesByTrackingUniqueIdentifiers[\r\n        trackingUniqueIdentifier\r\n      ] = [...ContentSequence];\r\n    } else {\r\n      // Add the ContentSequence minus the tracking identifier, as we have this\r\n      // Information in the merged ContentSequence anyway.\r\n      ContentSequence.forEach(item => {\r\n        if (\r\n          item.ConceptNameCodeSequence.CodeValue !==\r\n          CodeNameCodeSequenceValues.TrackingUniqueIdentifier\r\n        ) {\r\n          mergedContentSequencesByTrackingUniqueIdentifiers[\r\n            trackingUniqueIdentifier\r\n          ].push(item);\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  return mergedContentSequencesByTrackingUniqueIdentifiers;\r\n}\r\n\r\nfunction _processMeasurement(mergedContentSequence) {\r\n  if (\r\n    mergedContentSequence.some(\r\n      group => group.ValueType === 'SCOORD' || group.ValueType === 'SCOORD3D'\r\n    )\r\n  ) {\r\n    return _processTID1410Measurement(mergedContentSequence);\r\n  }\r\n\r\n  return _processNonGeometricallyDefinedMeasurement(mergedContentSequence);\r\n}\r\n\r\nfunction _processTID1410Measurement(mergedContentSequence) {\r\n  // Need to deal with TID 1410 style measurements, which will have a SCOORD or SCOORD3D at the top level,\r\n  // And non-geometric representations where each NUM has \"INFERRED FROM\" SCOORD/SCOORD3D\r\n\r\n  const graphicItem = mergedContentSequence.find(\r\n    group => group.ValueType === 'SCOORD'\r\n  );\r\n\r\n  const UIDREFContentItem = mergedContentSequence.find(\r\n    group => group.ValueType === 'UIDREF'\r\n  );\r\n\r\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.TrackingIdentifier\r\n  );\r\n\r\n  if (!graphicItem) {\r\n    console.warn(\r\n      `graphic ValueType ${graphicItem.ValueType} not currently supported, skipping annotation.`\r\n    );\r\n    return;\r\n  }\r\n\r\n  const NUMContentItems = mergedContentSequence.filter(\r\n    group => group.ValueType === 'NUM'\r\n  );\r\n\r\n  const measurement = {\r\n    loaded: false,\r\n    labels: [],\r\n    coords: [_getCoordsFromSCOORDOrSCOORD3D(graphicItem)],\r\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\r\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\r\n  };\r\n\r\n  NUMContentItems.forEach(item => {\r\n    const { ConceptNameCodeSequence, MeasuredValueSequence } = item;\r\n\r\n    if (MeasuredValueSequence) {\r\n      measurement.labels.push(\r\n        _getLabelFromMeasuredValueSequence(\r\n          ConceptNameCodeSequence,\r\n          MeasuredValueSequence\r\n        )\r\n      );\r\n    }\r\n  });\r\n\r\n  return measurement;\r\n}\r\n\r\nfunction _processNonGeometricallyDefinedMeasurement(mergedContentSequence) {\r\n  const NUMContentItems = mergedContentSequence.filter(\r\n    group => group.ValueType === 'NUM'\r\n  );\r\n\r\n  const UIDREFContentItem = mergedContentSequence.find(\r\n    group => group.ValueType === 'UIDREF'\r\n  );\r\n\r\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.TrackingIdentifier\r\n  );\r\n\r\n  const finding = mergedContentSequence.find(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.Finding\r\n  );\r\n\r\n  const findingSites = mergedContentSequence.filter(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodingSchemeDesignator ===\r\n        CodingSchemeDesignators.SRT &&\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n        CodeNameCodeSequenceValues.FindingSite\r\n  );\r\n\r\n  const measurement = {\r\n    loaded: false,\r\n    labels: [],\r\n    coords: [],\r\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\r\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\r\n  };\r\n\r\n  if (\r\n    finding &&\r\n    CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\r\n      finding.ConceptCodeSequence.CodingSchemeDesignator\r\n    ) &&\r\n    finding.ConceptCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.CornerstoneFreeText\r\n  ) {\r\n    measurement.labels.push({\r\n      label: CORNERSTONE_FREETEXT_CODE_VALUE,\r\n      value: finding.ConceptCodeSequence.CodeMeaning,\r\n    });\r\n  }\r\n\r\n  // TODO -> Eventually hopefully support SNOMED or some proper code library, just free text for now.\r\n  if (findingSites.length) {\r\n    const cornerstoneFreeTextFindingSite = findingSites.find(\r\n      FindingSite =>\r\n        CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\r\n          FindingSite.ConceptCodeSequence.CodingSchemeDesignator\r\n        ) &&\r\n        FindingSite.ConceptCodeSequence.CodeValue ===\r\n          CodeNameCodeSequenceValues.CornerstoneFreeText\r\n    );\r\n\r\n    if (cornerstoneFreeTextFindingSite) {\r\n      measurement.labels.push({\r\n        label: CORNERSTONE_FREETEXT_CODE_VALUE,\r\n        value: cornerstoneFreeTextFindingSite.ConceptCodeSequence.CodeMeaning,\r\n      });\r\n    }\r\n  }\r\n\r\n  NUMContentItems.forEach(item => {\r\n    const {\r\n      ConceptNameCodeSequence,\r\n      ContentSequence,\r\n      MeasuredValueSequence,\r\n    } = item;\r\n\r\n    const { ValueType } = ContentSequence;\r\n\r\n    if (!ValueType === 'SCOORD') {\r\n      console.warn(\r\n        `Graphic ${ValueType} not currently supported, skipping annotation.`\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    const coords = _getCoordsFromSCOORDOrSCOORD3D(ContentSequence);\r\n\r\n    if (coords) {\r\n      measurement.coords.push(coords);\r\n    }\r\n\r\n    if (MeasuredValueSequence) {\r\n      measurement.labels.push(\r\n        _getLabelFromMeasuredValueSequence(\r\n          ConceptNameCodeSequence,\r\n          MeasuredValueSequence\r\n        )\r\n      );\r\n    }\r\n  });\r\n\r\n  return measurement;\r\n}\r\n\r\nfunction _getCoordsFromSCOORDOrSCOORD3D(item) {\r\n  const { ValueType, RelationshipType, GraphicType, GraphicData } = item;\r\n\r\n  if (\r\n    !(\r\n      RelationshipType == RELATIONSHIP_TYPE.INFERRED_FROM ||\r\n      RelationshipType == RELATIONSHIP_TYPE.CONTAINS\r\n    )\r\n  ) {\r\n    console.warn(\r\n      `Relationshiptype === ${RelationshipType}. Cannot deal with NON TID-1400 SCOORD group with RelationshipType !== \"INFERRED FROM\" or \"CONTAINS\"`\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  const coords = { ValueType, GraphicType, GraphicData };\r\n\r\n  // ContentSequence has length of 1 as RelationshipType === 'INFERRED FROM'\r\n  if (ValueType === 'SCOORD') {\r\n    const { ReferencedSOPSequence } = item.ContentSequence;\r\n\r\n    coords.ReferencedSOPSequence = ReferencedSOPSequence;\r\n  } else if (ValueType === 'SCOORD3D') {\r\n    const { ReferencedFrameOfReferenceSequence } = item.ContentSequence;\r\n\r\n    coords.ReferencedFrameOfReferenceSequence = ReferencedFrameOfReferenceSequence;\r\n  }\r\n\r\n  return coords;\r\n}\r\n\r\nfunction _getLabelFromMeasuredValueSequence(\r\n  ConceptNameCodeSequence,\r\n  MeasuredValueSequence\r\n) {\r\n  const { CodeMeaning } = ConceptNameCodeSequence;\r\n  const { NumericValue, MeasurementUnitsCodeSequence } = MeasuredValueSequence;\r\n  const { CodeValue } = MeasurementUnitsCodeSequence;\r\n\r\n  const formatedNumericValue = NumericValue\r\n    ? Number(NumericValue).toFixed(2)\r\n    : '';\r\n\r\n  return {\r\n    label: CodeMeaning,\r\n    value: `${formatedNumericValue} ${CodeValue}`,\r\n  }; // E.g. Long Axis: 31.0 mm\r\n}\r\n\r\nfunction _getReferencedImagesList(ImagingMeasurementReportContentSequence) {\r\n  const ImageLibrary = ImagingMeasurementReportContentSequence.find(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.ImageLibrary\r\n  );\r\n\r\n  const ImageLibraryGroup = _getSequenceAsArray(\r\n    ImageLibrary.ContentSequence\r\n  ).find(\r\n    item =>\r\n      item.ConceptNameCodeSequence.CodeValue ===\r\n      CodeNameCodeSequenceValues.ImageLibraryGroup\r\n  );\r\n\r\n  const referencedImages = [];\r\n\r\n  _getSequenceAsArray(ImageLibraryGroup.ContentSequence).forEach(item => {\r\n    const { ReferencedSOPSequence } = item;\r\n    if (!ReferencedSOPSequence) return;\r\n    for (const ref of _getSequenceAsArray(ReferencedSOPSequence)) {\r\n      if (ref.ReferencedSOPClassUID) {\r\n        const { ReferencedSOPClassUID, ReferencedSOPInstanceUID } = ref;\r\n\r\n        referencedImages.push({\r\n          ReferencedSOPClassUID,\r\n          ReferencedSOPInstanceUID,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  return referencedImages;\r\n}\r\n\r\nfunction _getSequenceAsArray(sequence) {\r\n  if (!sequence) return [];\r\n  return Array.isArray(sequence) ? sequence : [sequence];\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import { Types } from '@ohif/core';\r\n\r\nconst srProtocol: Types.HangingProtocol.Protocol = {\r\n  id: '@ohif/sr',\r\n  // Don't store this hanging protocol as it applies to the currently active\r\n  // display set by default\r\n  // cacheId: null,\r\n  hasUpdatedPriorsInformation: false,\r\n  name: 'SR Key Images',\r\n  // Just apply this one when specifically listed\r\n  protocolMatchingRules: [],\r\n  toolGroupIds: ['default'],\r\n  // -1 would be used to indicate active only, whereas other values are\r\n  // the number of required priors referenced - so 0 means active with\r\n  // 0 or more priors.\r\n  numberOfPriorsReferenced: 0,\r\n  // Default viewport is used to define the viewport when\r\n  // additional viewports are added using the layout tool\r\n  defaultViewport: {\r\n    viewportOptions: {\r\n      viewportType: 'stack',\r\n      toolGroupId: 'default',\r\n      allowUnmatchedView: true,\r\n    },\r\n    displaySets: [\r\n      {\r\n        id: 'srDisplaySetId',\r\n        matchedDisplaySetsIndex: -1,\r\n      },\r\n    ],\r\n  },\r\n  displaySetSelectors: {\r\n    srDisplaySetId: {\r\n      seriesMatchingRules: [\r\n        {\r\n          attribute: 'Modality',\r\n          constraint: {\r\n            equals: 'SR',\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  stages: [\r\n    {\r\n      name: 'SR Key Images',\r\n      viewportStructure: {\r\n        layoutType: 'grid',\r\n        properties: {\r\n          rows: 1,\r\n          columns: 1,\r\n        },\r\n      },\r\n      viewports: [\r\n        {\r\n          viewportOptions: { allowUnmatchedView: true },\r\n          displaySets: [\r\n            {\r\n              id: 'srDisplaySetId',\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\nfunction getHangingProtocolModule() {\r\n  return [\r\n    {\r\n      name: srProtocol.id,\r\n      protocol: srProtocol,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getHangingProtocolModule;\r\nexport { srProtocol };\r\n","import OHIF from '@ohif/core';\r\nimport { annotation } from '@cornerstonejs/tools';\r\nconst { log } = OHIF;\r\n\r\nfunction getFilteredCornerstoneToolState(\r\n  measurementData,\r\n  additionalFindingTypes\r\n) {\r\n  const filteredToolState = {};\r\n\r\n  function addToFilteredToolState(annotation, toolType) {\r\n    if (!annotation.metadata?.referencedImageId) {\r\n      log.warn(\r\n        `[DICOMSR] No referencedImageId found for ${toolType} ${annotation.id}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const imageId = annotation.metadata.referencedImageId;\r\n\r\n    if (!filteredToolState[imageId]) {\r\n      filteredToolState[imageId] = {};\r\n    }\r\n\r\n    const imageIdSpecificToolState = filteredToolState[imageId];\r\n\r\n    if (!imageIdSpecificToolState[toolType]) {\r\n      imageIdSpecificToolState[toolType] = {\r\n        data: [],\r\n      };\r\n    }\r\n\r\n    const measurementDataI = measurementData.find(\r\n      md => md.uid === annotation.annotationUID\r\n    );\r\n    const toolData = imageIdSpecificToolState[toolType].data;\r\n\r\n    let { finding } = measurementDataI;\r\n    const findingSites = [];\r\n\r\n    // NOTE -> We use the CORNERSTONEJS coding schemeDesignator which we have\r\n    // defined in the @cornerstonejs/adapters\r\n    if (measurementDataI.label) {\r\n      if (additionalFindingTypes.includes(toolType)) {\r\n        finding = {\r\n          CodeValue: 'CORNERSTONEFREETEXT',\r\n          CodingSchemeDesignator: 'CORNERSTONEJS',\r\n          CodeMeaning: measurementDataI.label,\r\n        };\r\n      } else {\r\n        findingSites.push({\r\n          CodeValue: 'CORNERSTONEFREETEXT',\r\n          CodingSchemeDesignator: 'CORNERSTONEJS',\r\n          CodeMeaning: measurementDataI.label,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (measurementDataI.findingSites) {\r\n      findingSites.push(...measurementDataI.findingSites);\r\n    }\r\n\r\n    const measurement = Object.assign({}, annotation, {\r\n      finding,\r\n      findingSites,\r\n    });\r\n\r\n    toolData.push(measurement);\r\n  }\r\n\r\n  const uidFilter = measurementData.map(md => md.uid);\r\n  const uids = uidFilter.slice();\r\n\r\n  const annotationManager = annotation.state.getAnnotationManager();\r\n  const framesOfReference = annotationManager.getFramesOfReference();\r\n\r\n  for (let i = 0; i < framesOfReference.length; i++) {\r\n    const frameOfReference = framesOfReference[i];\r\n\r\n    const frameOfReferenceAnnotations = annotationManager.getAnnotations(\r\n      frameOfReference\r\n    );\r\n\r\n    const toolTypes = Object.keys(frameOfReferenceAnnotations);\r\n\r\n    for (let j = 0; j < toolTypes.length; j++) {\r\n      const toolType = toolTypes[j];\r\n\r\n      const annotations = frameOfReferenceAnnotations[toolType];\r\n\r\n      if (annotations) {\r\n        for (let k = 0; k < annotations.length; k++) {\r\n          const annotation = annotations[k];\r\n          const uidIndex = uids.findIndex(\r\n            uid => uid === annotation.annotationUID\r\n          );\r\n\r\n          if (uidIndex !== -1) {\r\n            addToFilteredToolState(annotation, toolType);\r\n            uids.splice(uidIndex, 1);\r\n\r\n            if (!uids.length) {\r\n              return filteredToolState;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return filteredToolState;\r\n}\r\n\r\nexport default getFilteredCornerstoneToolState;\r\n","import { metaData, utilities } from '@cornerstonejs/core';\r\n\r\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\r\nimport dcmjs from 'dcmjs';\r\nimport { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nimport getFilteredCornerstoneToolState from './utils/getFilteredCornerstoneToolState';\r\n\r\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\r\nconst { log } = OHIF;\r\n\r\n/**\r\n *\r\n * @param measurementData An array of measurements from the measurements service\r\n * that you wish to serialize.\r\n * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\r\n * @param options Naturalized DICOM JSON headers to merge into the displaySet.\r\n *\r\n */\r\nconst _generateReport = (\r\n  measurementData,\r\n  additionalFindingTypes,\r\n  options = {}\r\n) => {\r\n  const filteredToolState = getFilteredCornerstoneToolState(\r\n    measurementData,\r\n    additionalFindingTypes\r\n  );\r\n\r\n  const report = MeasurementReport.generateReport(\r\n    filteredToolState,\r\n    metaData,\r\n    utilities.worldToImageCoords,\r\n    options\r\n  );\r\n\r\n  const { dataset } = report;\r\n\r\n  // Set the default character set as UTF-8\r\n  // https://dicom.innolitics.com/ciods/nm-image/sop-common/00080005\r\n  if (typeof dataset.SpecificCharacterSet === 'undefined') {\r\n    dataset.SpecificCharacterSet = 'ISO_IR 192';\r\n  }\r\n  return dataset;\r\n};\r\n\r\nconst commandsModule = ({}) => {\r\n  const actions = {\r\n    /**\r\n     *\r\n     * @param measurementData An array of measurements from the measurements service\r\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\r\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\r\n     * as opposed to Finding Sites.\r\n     * that you wish to serialize.\r\n     */\r\n    downloadReport: ({\r\n      measurementData,\r\n      additionalFindingTypes,\r\n      options = {},\r\n    }) => {\r\n      const srDataset = actions.generateReport(\r\n        measurementData,\r\n        additionalFindingTypes,\r\n        options\r\n      );\r\n      const reportBlob = dcmjs.data.datasetToBlob(srDataset);\r\n\r\n      //Create a URL for the binary.\r\n      var objectUrl = URL.createObjectURL(reportBlob);\r\n      window.location.assign(objectUrl);\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param measurementData An array of measurements from the measurements service\r\n     * that you wish to serialize.\r\n     * @param dataSource The dataSource that you wish to use to persist the data.\r\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\r\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\r\n     * @return The naturalized report\r\n     */\r\n    storeMeasurements: async ({\r\n      measurementData,\r\n      dataSource,\r\n      additionalFindingTypes,\r\n      options = {},\r\n    }) => {\r\n      // Use the @cornerstonejs adapter for converting to/from DICOM\r\n      // But it is good enough for now whilst we only have cornerstone as a datasource.\r\n      log.info('[DICOMSR] storeMeasurements');\r\n\r\n      if (!dataSource || !dataSource.store || !dataSource.store.dicom) {\r\n        log.error(\r\n          '[DICOMSR] datasource has no dataSource.store.dicom endpoint!'\r\n        );\r\n        return Promise.reject({});\r\n      }\r\n\r\n      try {\r\n        const naturalizedReport = _generateReport(\r\n          measurementData,\r\n          additionalFindingTypes,\r\n          options\r\n        );\r\n\r\n        const { StudyInstanceUID, ContentSequence } = naturalizedReport;\r\n        // The content sequence has 5 or more elements, of which\r\n        // the `[4]` element contains the annotation data, so this is\r\n        // checking that there is some annotation data present.\r\n        if (!ContentSequence?.[4].ContentSequence?.length) {\r\n          console.log(\r\n            'naturalizedReport missing imaging content',\r\n            naturalizedReport\r\n          );\r\n          throw new Error('Invalid report, no content');\r\n        }\r\n\r\n        await dataSource.store.dicom(naturalizedReport);\r\n\r\n        if (StudyInstanceUID) {\r\n          dataSource.deleteStudyMetadataPromise(StudyInstanceUID);\r\n        }\r\n\r\n        // The \"Mode\" route listens for DicomMetadataStore changes\r\n        // When a new instance is added, it listens and\r\n        // automatically calls makeDisplaySets\r\n        DicomMetadataStore.addInstances([naturalizedReport], true);\r\n\r\n        return naturalizedReport;\r\n      } catch (error) {\r\n        console.warn(error);\r\n        log.error(\r\n          `[DICOMSR] Error while saving the measurements: ${error.message}`\r\n        );\r\n        throw new Error(\r\n          error.message || 'Error while saving the measurements.'\r\n        );\r\n      }\r\n    },\r\n  };\r\n\r\n  const definitions = {\r\n    downloadReport: {\r\n      commandFn: actions.downloadReport,\r\n      storeContexts: [],\r\n      options: {},\r\n    },\r\n    storeMeasurements: {\r\n      commandFn: actions.storeMeasurements,\r\n      storeContexts: [],\r\n      options: {},\r\n    },\r\n  };\r\n\r\n  return {\r\n    actions,\r\n    definitions,\r\n    defaultContext: 'CORNERSTONE_STRUCTURED_REPORT',\r\n  };\r\n};\r\n\r\nexport default commandsModule;\r\n","import { addTool } from '@cornerstonejs/tools';\r\n\r\nexport default function addToolInstance(\r\n  name: string,\r\n  toolClass,\r\n  configuration?\r\n): void {\r\n  class InstanceClass extends toolClass {\r\n    static toolName = name;\r\n  }\r\n  addTool(InstanceClass);\r\n}\r\n","import { DisplaySetService, classes } from '@ohif/core';\r\n\r\nconst ImageSet = classes.ImageSet;\r\n\r\nconst findInstance = (measurement, displaySetService: DisplaySetService) => {\r\n  const { displaySetInstanceUID, ReferencedSOPInstanceUID: sopUid } =\r\n    measurement;\r\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\r\n    displaySetInstanceUID\r\n  );\r\n  if (!referencedDisplaySet.images) return;\r\n  return referencedDisplaySet.images.find(it => it.SOPInstanceUID === sopUid);\r\n};\r\n\r\n/** Finds references to display sets inside the measurements\r\n * contained within the provided display set.\r\n * @return an array of instances referenced.\r\n */\r\nconst findReferencedInstances = (\r\n  displaySetService: DisplaySetService,\r\n  displaySet\r\n) => {\r\n  const instances = [];\r\n  const instanceById = {};\r\n  for (const measurement of displaySet.measurements) {\r\n    const { imageId } = measurement;\r\n    if (!imageId) continue;\r\n    if (instanceById[imageId]) continue;\r\n\r\n    const instance = findInstance(measurement, displaySetService);\r\n    if (!instance) {\r\n      console.log('Measurement', measurement, 'had no instances found');\r\n      continue;\r\n    }\r\n\r\n    instanceById[imageId] = instance;\r\n    instances.push(instance);\r\n  }\r\n  return instances;\r\n};\r\n\r\n/**\r\n * Creates a new display set containing a single image instance for each\r\n * referenced image.\r\n *\r\n * @param displaySetService\r\n * @param displaySet - containing measurements referencing images.\r\n * @returns A new (registered/active) display set containing the referenced images\r\n */\r\nconst createReferencedImageDisplaySet = (displaySetService, displaySet) => {\r\n  const instances = findReferencedInstances(displaySetService, displaySet);\r\n  // This will be a  member function of the created image set\r\n  const updateInstances = function() {\r\n    this.images.splice(\r\n      0,\r\n      this.images.length,\r\n      ...findReferencedInstances(displaySetService, displaySet)\r\n    );\r\n    this.numImageFrames = this.images.length;\r\n  };\r\n\r\n  const imageSet = new ImageSet(instances);\r\n  const instance = instances[0];\r\n  imageSet.setAttributes({\r\n    displaySetInstanceUID: imageSet.uid, // create a local alias for the imageSet UID\r\n    SeriesDate: instance.SeriesDate,\r\n    SeriesTime: instance.SeriesTime,\r\n    SeriesInstanceUID: imageSet.uid,\r\n    StudyInstanceUID: instance.StudyInstanceUID,\r\n    SeriesNumber: instance.SeriesNumber || 0,\r\n    SOPClassUID: instance.SOPClassUID,\r\n    SeriesDescription: `${displaySet.SeriesDescription} KO ${displaySet.instance.SeriesNumber}`,\r\n    Modality: 'KO',\r\n    isMultiFrame: false,\r\n    numImageFrames: instances.length,\r\n    SOPClassHandlerId: `@ohif/extension-default.sopClassHandlerModule.stack`,\r\n    isReconstructable: false,\r\n    // This object is made of multiple instances from other series\r\n    isCompositeStack: true,\r\n    madeInClient: true,\r\n    excludeFromThumbnailBrowser: true,\r\n    updateInstances,\r\n  });\r\n\r\n  displaySetService.addDisplaySets(imageSet);\r\n\r\n  return imageSet;\r\n};\r\n\r\nexport default createReferencedImageDisplaySet;\r\n","import React from 'react';\r\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\r\nimport getHangingProtocolModule, {\r\n  srProtocol,\r\n} from './getHangingProtocolModule';\r\nimport onModeEnter from './onModeEnter';\r\nimport getCommandsModule from './commandsModule';\r\nimport preRegistration from './init';\r\nimport { id } from './id.js';\r\nimport toolNames from './tools/toolNames';\r\nimport hydrateStructuredReport from './utils/hydrateStructuredReport';\r\nimport createReferencedImageDisplaySet from './utils/createReferencedImageDisplaySet';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(\r\n    /* webpackPrefetch: true */ './viewports/OHIFCornerstoneSRViewport'\r\n  );\r\n});\r\n\r\nconst OHIFCornerstoneSRViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n *\r\n */\r\nconst dicomSRExtension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   */\r\n  id,\r\n  onModeEnter,\r\n\r\n  preRegistration,\r\n\r\n  /**\r\n   *\r\n   *\r\n   * @param {object} [configuration={}]\r\n   * @param {object|array} [configuration.csToolsConfig] - Passed directly to `initCornerstoneTools`\r\n   */\r\n  getViewportModule({ servicesManager, extensionManager }) {\r\n    const ExtendedOHIFCornerstoneSRViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneSRViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [{ name: 'dicom-sr', component: ExtendedOHIFCornerstoneSRViewport }];\r\n  },\r\n  getCommandsModule,\r\n  getSopClassHandlerModule,\r\n  // Include dynmically computed values such as toolNames not known till instantiation\r\n  getUtilityModule({ servicesManager }) {\r\n    return [\r\n      {\r\n        name: 'tools',\r\n        exports: {\r\n          toolNames,\r\n        },\r\n      },\r\n    ];\r\n  },\r\n};\r\n\r\nexport default dicomSRExtension;\r\n\r\n// Put static exports here so they can be type checked\r\nexport { hydrateStructuredReport, createReferencedImageDisplaySet, srProtocol };\r\n","import { SOPClassHandlerId } from './id';\r\n\r\nexport default function onModeEnter({ servicesManager }) {\r\n  const { displaySetService } = servicesManager.services;\r\n  const displaySetCache = displaySetService.getDisplaySetCache();\r\n\r\n  const srDisplaySets = [...displaySetCache.values()].filter(\r\n    ds => ds.SOPClassHandlerId === SOPClassHandlerId\r\n  );\r\n\r\n  srDisplaySets.forEach(ds => {\r\n    // New mode route, allow SRs to be hydrated again\r\n    ds.isHydrated = false;\r\n  });\r\n}\r\n","import {\r\n  addTool,\r\n  AngleTool,\r\n  annotation,\r\n  ArrowAnnotateTool,\r\n  BidirectionalTool,\r\n  CobbAngleTool,\r\n  EllipticalROITool,\r\n  CircleROITool,\r\n  LengthTool,\r\n  PlanarFreehandROITool,\r\n} from '@cornerstonejs/tools';\r\nimport DICOMSRDisplayTool from './tools/DICOMSRDisplayTool';\r\nimport addToolInstance from './utils/addToolInstance';\r\nimport { Types } from '@ohif/core';\r\nimport toolNames from './tools/toolNames';\r\n\r\n/**\r\n * @param {object} configuration\r\n */\r\nexport default function init({\r\n  configuration = {},\r\n}: Types.Extensions.ExtensionParams): void {\r\n  addTool(DICOMSRDisplayTool);\r\n  addToolInstance(toolNames.SRLength, LengthTool, {});\r\n  addToolInstance(toolNames.SRBidirectional, BidirectionalTool);\r\n  addToolInstance(toolNames.SREllipticalROI, EllipticalROITool);\r\n  addToolInstance(toolNames.SRCircleROI, CircleROITool);\r\n  addToolInstance(toolNames.SRArrowAnnotate, ArrowAnnotateTool);\r\n  addToolInstance(toolNames.SRAngle, AngleTool);\r\n  // TODO - fix the SR display of Cobb Angle, as it joins the two lines\r\n  addToolInstance(toolNames.SRCobbAngle, CobbAngleTool);\r\n  // TODO - fix the rehydration of Freehand, as it throws an exception\r\n  // on a missing polyline. The fix is probably in CS3D\r\n  addToolInstance(toolNames.SRPlanarFreehandROI, PlanarFreehandROITool);\r\n\r\n  // Modify annotation tools to use dashed lines on SR\r\n  const dashedLine = {\r\n    lineDash: '4,4',\r\n  };\r\n  annotation.config.style.setToolGroupToolStyles('SRToolGroup', {\r\n    SRLength: dashedLine,\r\n    SRBidirectional: dashedLine,\r\n    SREllipticalROI: dashedLine,\r\n    SRCircleROI: dashedLine,\r\n    SRArrowAnnotate: dashedLine,\r\n    SRCobbAngle: dashedLine,\r\n    SRAngle: dashedLine,\r\n    SRPlanarFreehandROI: dashedLine,\r\n    global: {},\r\n  });\r\n}\r\n","import { getEnabledElement } from '@cornerstonejs/core';\r\n\r\nconst state = {\r\n  TrackingUniqueIdentifier: null,\r\n  trackingIdentifiersByViewportId: {},\r\n};\r\n\r\n/**\r\n * This file is being used to store the per-viewport state of the SR tools,\r\n * Since, all the toolStates are added to the cornerstoneTools, when displaying the SRTools,\r\n * if there are two viewports rendering the same imageId, we don't want to show\r\n * the same SR annotation twice on irrelevant viewport, hence, we are storing the state\r\n * of the SR tools in state here, so that we can filter them later.\r\n */\r\n\r\nfunction setTrackingUniqueIdentifiersForElement(\r\n  element,\r\n  trackingUniqueIdentifiers,\r\n  activeIndex = 0\r\n) {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  state.trackingIdentifiersByViewportId[viewport.id] = {\r\n    trackingUniqueIdentifiers,\r\n    activeIndex,\r\n  };\r\n}\r\n\r\nfunction setActiveTrackingUniqueIdentifierForElement(\r\n  element,\r\n  TrackingUniqueIdentifier\r\n) {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  const trackingIdentifiersForElement =\r\n    state.trackingIdentifiersByViewportId[viewport.id];\r\n\r\n  if (trackingIdentifiersForElement) {\r\n    const activeIndex = trackingIdentifiersForElement.trackingUniqueIdentifiers.findIndex(\r\n      tuid => tuid === TrackingUniqueIdentifier\r\n    );\r\n\r\n    trackingIdentifiersForElement.activeIndex = activeIndex;\r\n  }\r\n}\r\n\r\nfunction getTrackingUniqueIdentifiersForElement(element) {\r\n  const enabledElement = getEnabledElement(element);\r\n  const { viewport } = enabledElement;\r\n\r\n  if (state.trackingIdentifiersByViewportId[viewport.id]) {\r\n    return state.trackingIdentifiersByViewportId[viewport.id];\r\n  }\r\n\r\n  return { trackingUniqueIdentifiers: [] };\r\n}\r\n\r\nexport {\r\n  setTrackingUniqueIdentifiersForElement,\r\n  setActiveTrackingUniqueIdentifierForElement,\r\n  getTrackingUniqueIdentifiersForElement,\r\n};\r\n","import { utilities, metaData } from '@cornerstonejs/core';\r\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\r\nimport getLabelFromDCMJSImportedToolData from './getLabelFromDCMJSImportedToolData';\r\nimport { adaptersSR } from '@cornerstonejs/adapters';\r\n\r\nconst { guid } = OHIF.utils;\r\nconst { MeasurementReport, CORNERSTONE_3D_TAG } = adaptersSR.Cornerstone3D;\r\n\r\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\r\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\r\n\r\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\r\n\r\nconst convertCode = (codingValues, code) => {\r\n  if (!code || code.CodingSchemeDesignator === 'CORNERSTONEJS') return;\r\n  const ref = `${code.CodingSchemeDesignator}:${code.CodeValue}`;\r\n  const ret = { ...codingValues[ref], ref, ...code, text: code.CodeMeaning };\r\n  return ret;\r\n};\r\n\r\nconst convertSites = (codingValues, sites) => {\r\n  if (!sites || !sites.length) return;\r\n  const ret = [];\r\n  // Do as a loop to convert away from Proxy instances\r\n  for (let i = 0; i < sites.length; i++) {\r\n    // Deal with irregular conversion from dcmjs\r\n    const site = convertCode(codingValues, sites[i][0] || sites[i]);\r\n    if (site) ret.push(site);\r\n  }\r\n  return (ret.length && ret) || undefined;\r\n};\r\n\r\n/**\r\n * Hydrates a structured report, for default viewports.\r\n *\r\n */\r\nexport default function hydrateStructuredReport(\r\n  { servicesManager, extensionManager },\r\n  displaySetInstanceUID\r\n) {\r\n  const dataSource = extensionManager.getActiveDataSource()[0];\r\n  const {\r\n    measurementService,\r\n    displaySetService,\r\n    customizationService,\r\n  } = servicesManager.services;\r\n\r\n  const codingValues = customizationService.getCustomization(\r\n    'codingValues',\r\n    {}\r\n  );\r\n  const displaySet = displaySetService.getDisplaySetByUID(\r\n    displaySetInstanceUID\r\n  );\r\n\r\n  // TODO -> We should define a strict versioning somewhere.\r\n  const mappings = measurementService.getSourceMappings(\r\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\r\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\r\n  );\r\n\r\n  if (!mappings || !mappings.length) {\r\n    throw new Error(\r\n      `Attempting to hydrate measurements service when no mappings present. This shouldn't be reached.`\r\n    );\r\n  }\r\n\r\n  const instance = DicomMetadataStore.getInstance(\r\n    displaySet.StudyInstanceUID,\r\n    displaySet.SeriesInstanceUID,\r\n    displaySet.SOPInstanceUID\r\n  );\r\n\r\n  const sopInstanceUIDToImageId = {};\r\n  const imageIdsForToolState = {};\r\n\r\n  displaySet.measurements.forEach(measurement => {\r\n    const { ReferencedSOPInstanceUID, imageId, frameNumber } = measurement;\r\n\r\n    if (!sopInstanceUIDToImageId[ReferencedSOPInstanceUID]) {\r\n      sopInstanceUIDToImageId[ReferencedSOPInstanceUID] = imageId;\r\n      imageIdsForToolState[ReferencedSOPInstanceUID] = [];\r\n    }\r\n    if (!imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber]) {\r\n      imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber] = imageId;\r\n    }\r\n  });\r\n\r\n  const datasetToUse = _mapLegacyDataSet(instance);\r\n\r\n  // Use dcmjs to generate toolState.\r\n  const storedMeasurementByAnnotationType = MeasurementReport.generateToolState(\r\n    datasetToUse,\r\n    // NOTE: we need to pass in the imageIds to dcmjs since the we use them\r\n    // for the imageToWorld transformation. The following assumes that the order\r\n    // that measurements were added to the display set are the same order as\r\n    // the measurementGroups in the instance.\r\n    sopInstanceUIDToImageId,\r\n    utilities.imageToWorldCoords,\r\n    metaData\r\n  );\r\n\r\n  // Filter what is found by DICOM SR to measurements we support.\r\n  const mappingDefinitions = mappings.map(m => m.annotationType);\r\n  const hydratableMeasurementsInSR = {};\r\n\r\n  Object.keys(storedMeasurementByAnnotationType).forEach(key => {\r\n    if (mappingDefinitions.includes(key)) {\r\n      hydratableMeasurementsInSR[key] = storedMeasurementByAnnotationType[key];\r\n    }\r\n  });\r\n\r\n  // Set the series touched as tracked.\r\n  const imageIds = [];\r\n\r\n  // TODO: notification if no hydratable?\r\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\r\n    const toolDataForAnnotationType =\r\n      hydratableMeasurementsInSR[annotationType];\r\n\r\n    toolDataForAnnotationType.forEach(toolData => {\r\n      // Add the measurement to toolState\r\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\r\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\r\n      // in the wrong value.\r\n      const frameNumber =\r\n        (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\r\n      const imageId =\r\n        imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\r\n        sopInstanceUIDToImageId[toolData.sopInstanceUid];\r\n\r\n      if (!imageIds.includes(imageId)) {\r\n        imageIds.push(imageId);\r\n      }\r\n    });\r\n  });\r\n\r\n  let targetStudyInstanceUID;\r\n  const SeriesInstanceUIDs = [];\r\n\r\n  for (let i = 0; i < imageIds.length; i++) {\r\n    const imageId = imageIds[i];\r\n    const { SeriesInstanceUID, StudyInstanceUID } = metaData.get(\r\n      'instance',\r\n      imageId\r\n    );\r\n\r\n    if (!SeriesInstanceUIDs.includes(SeriesInstanceUID)) {\r\n      SeriesInstanceUIDs.push(SeriesInstanceUID);\r\n    }\r\n\r\n    if (!targetStudyInstanceUID) {\r\n      targetStudyInstanceUID = StudyInstanceUID;\r\n    } else if (targetStudyInstanceUID !== StudyInstanceUID) {\r\n      console.warn(\r\n        'NO SUPPORT FOR SRs THAT HAVE MEASUREMENTS FROM MULTIPLE STUDIES.'\r\n      );\r\n    }\r\n  }\r\n\r\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\r\n    const toolDataForAnnotationType =\r\n      hydratableMeasurementsInSR[annotationType];\r\n\r\n    toolDataForAnnotationType.forEach(toolData => {\r\n      // Add the measurement to toolState\r\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\r\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\r\n      // in the wrong value.\r\n      const frameNumber =\r\n        (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\r\n      const imageId =\r\n        imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\r\n        sopInstanceUIDToImageId[toolData.sopInstanceUid];\r\n\r\n      toolData.uid = guid();\r\n\r\n      const instance = metaData.get('instance', imageId);\r\n      const {\r\n        FrameOfReferenceUID,\r\n        // SOPInstanceUID,\r\n        // SeriesInstanceUID,\r\n        // StudyInstanceUID,\r\n      } = instance;\r\n\r\n      const annotation = {\r\n        annotationUID: toolData.annotation.annotationUID,\r\n        data: toolData.annotation.data,\r\n        metadata: {\r\n          toolName: annotationType,\r\n          referencedImageId: imageId,\r\n          FrameOfReferenceUID,\r\n        },\r\n      };\r\n\r\n      const source = measurementService.getSource(\r\n        CORNERSTONE_3D_TOOLS_SOURCE_NAME,\r\n        CORNERSTONE_3D_TOOLS_SOURCE_VERSION\r\n      );\r\n      annotation.data.label = getLabelFromDCMJSImportedToolData(toolData);\r\n      annotation.data.finding = convertCode(\r\n        codingValues,\r\n        toolData.finding?.[0]\r\n      );\r\n      annotation.data.findingSites = convertSites(\r\n        codingValues,\r\n        toolData.findingSites\r\n      );\r\n      annotation.data.site = annotation.data.findingSites?.[0];\r\n\r\n      const matchingMapping = mappings.find(\r\n        m => m.annotationType === annotationType\r\n      );\r\n\r\n      measurementService.addRawMeasurement(\r\n        source,\r\n        annotationType,\r\n        { annotation },\r\n        matchingMapping.toMeasurementSchema,\r\n        dataSource\r\n      );\r\n\r\n      if (!imageIds.includes(imageId)) {\r\n        imageIds.push(imageId);\r\n      }\r\n    });\r\n  });\r\n\r\n  displaySet.isHydrated = true;\r\n\r\n  return {\r\n    StudyInstanceUID: targetStudyInstanceUID,\r\n    SeriesInstanceUIDs,\r\n  };\r\n}\r\n\r\nfunction _mapLegacyDataSet(dataset) {\r\n  const REPORT = 'Imaging Measurements';\r\n  const GROUP = 'Measurement Group';\r\n  const TRACKING_IDENTIFIER = 'Tracking Identifier';\r\n\r\n  // Identify the Imaging Measurements\r\n  const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\r\n    codeMeaningEquals(REPORT)\r\n  );\r\n\r\n  // Retrieve the Measurements themselves\r\n  const measurementGroups = toArray(\r\n    imagingMeasurementContent.ContentSequence\r\n  ).filter(codeMeaningEquals(GROUP));\r\n\r\n  // For each of the supported measurement types, compute the measurement data\r\n  const measurementData = {};\r\n\r\n  const cornerstoneToolClasses =\r\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\r\n\r\n  const registeredToolClasses = [];\r\n\r\n  Object.keys(cornerstoneToolClasses).forEach(key => {\r\n    registeredToolClasses.push(cornerstoneToolClasses[key]);\r\n    measurementData[key] = [];\r\n  });\r\n\r\n  measurementGroups.forEach((measurementGroup, index) => {\r\n    const measurementGroupContentSequence = toArray(\r\n      measurementGroup.ContentSequence\r\n    );\r\n\r\n    const TrackingIdentifierGroup = measurementGroupContentSequence.find(\r\n      contentItem =>\r\n        contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER\r\n    );\r\n\r\n    const TrackingIdentifier = TrackingIdentifierGroup.TextValue;\r\n\r\n    let [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\r\n    if (supportedLegacyCornerstoneTags.includes(cornerstoneTag)) {\r\n      cornerstoneTag = CORNERSTONE_3D_TAG;\r\n    }\r\n\r\n    const mappedTrackingIdentifier = `${cornerstoneTag}:${toolName}`;\r\n\r\n    TrackingIdentifierGroup.TextValue = mappedTrackingIdentifier;\r\n  });\r\n\r\n  return dataset;\r\n}\r\n\r\nconst toArray = function (x) {\r\n  return Array.isArray(x) ? x : [x];\r\n};\r\n\r\nconst codeMeaningEquals = codeMeaningName => {\r\n  return contentItem => {\r\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\r\n  };\r\n};\r\n","/**\r\n * Extracts the label from the toolData imported from dcmjs. We need to do this\r\n * as dcmjs does not depeend on OHIF/the measurementService, it just produces data for cornestoneTools.\r\n * This optional data is available for the consumer to process if they wish to.\r\n * @param {object} toolData The tooldata relating to the\r\n *\r\n * @returns {string} The extracted label.\r\n */\r\nexport default function getLabelFromDCMJSImportedToolData(toolData) {\r\n  const { findingSites = [], finding } = toolData;\r\n\r\n  let freeTextLabel = findingSites.find(\r\n    fs => fs.CodeValue === 'CORNERSTONEFREETEXT'\r\n  );\r\n\r\n  if (freeTextLabel) {\r\n    return freeTextLabel.CodeMeaning;\r\n  }\r\n\r\n  if (finding && finding.CodeValue === 'CORNERSTONEFREETEXT') {\r\n    return finding.CodeMeaning;\r\n  }\r\n}\r\n"],"names":["id","packageJson","SOPClassHandlerName","SOPClassHandlerId","POINT","MULTIPOINT","POLYLINE","CIRCLE","ELLIPSE","DICOMSRDisplayTool","AnnotationTool","constructor","super","arguments","length","undefined","configuration","isPointNearTool","getHandleNearImagePoint","renderAnnotation","enabledElement","svgDrawingHelper","viewport","element","annotations","annotation","this","getToolName","filterInteractableAnnotationsForElement","trackingUniqueIdentifiersForElement","getTrackingUniqueIdentifiersForElement","activeIndex","trackingUniqueIdentifiers","activeTrackingUniqueIdentifier","filteredAnnotations","filter","includes","data","cachedStats","TrackingUniqueIdentifier","_actors","size","styleSpecifier","toolGroupId","toolName","viewportId","i","annotationUID","renderableData","referencedImageId","metadata","lineWidth","getStyle","lineDash","options","color","Object","keys","forEach","GraphicType","renderableDataForGraphicType","renderMethod","canvasCoordinatesAdapter","SCOORD_TYPES","renderPoint","renderMultipoint","renderPolyLine","renderEllipse","utilities","Error","canvasCoordinates","renderTextBox","_getTextBoxLinesFromLabels","labels","labelLength","Math","min","lines","labelEntry","push","_labelToShorthand","label","value","drawingOptions","width","allCanvasCoordinates","map","index","p","worldToCanvas","lineUID","drawing","concat","point","imagePixelModule","metaData","get","xOffset","yOffset","columns","rows","imagePoint","csUtils","arrowEnd","arrowUID","ellipsePointsWorld","rotation","getRotation","canvasCorners","adaptedCanvasCoordinates","textLines","canvasTextBoxCoords","handles","textBox","worldPosition","canvasToWorld","textBoxPosition","textBoxOptions","getLinkedTextBoxStyle","boundingBox","x","left","y","top","height","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","SHORT_HAND_MAP","AREA","Length","CORNERSTONEFREETEXT","shortHand","DICOMSRDisplay","SRLength","SRBidirectional","SREllipticalROI","SRCircleROI","SRArrowAnnotate","SRAngle","SRCobbAngle","SRRectangleROI","SRPlanarFreehandROI","EPSILON","addMeasurement","measurement","imageId","displaySetInstanceUID","toolNames","measurementData","coords","coord","GraphicData","TrackingIdentifier","cornerstoneTag","split","worldPos","pointsWorld","center","onPerimeter","radius","vec3","distance","imagePlaneModule","columnCosines","rowCosines","firstAxisStart","create","scaleAndAdd","firstAxisEnd","secondAxisStart","secondAxisEnd","majorAxisStart","fromValues","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","sub","normalize","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","abs","dot","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","console","warn","_getRenderableData","annotationManager","frameNumber","ReferencedSOPSequence","ReferencedFrameNumber","SRAnnotation","FrameOfReferenceUID","frameOfReferenceUID","addAnnotation","loaded","ReferencedSOPInstanceUID","cornerstoneAdapters","adaptersSR","supportedLegacyCornerstoneTags","CORNERSTONE_3D_TAG","CodeScheme","Cornerstone3DCodeScheme","ImageSet","MetadataProvider","metadataProvider","classes","sopClassUids","CORNERSTONE_3D_TOOLS_SOURCE_NAME","CORNERSTONE_3D_TOOLS_SOURCE_VERSION","validateSameStudyUID","uid","instances","it","StudyInstanceUID","SOPInstanceUID","CodeNameCodeSequenceValues","ImagingMeasurementReport","ImageLibrary","ImagingMeasurements","MeasurementGroup","ImageLibraryGroup","Finding","FindingSite","CornerstoneFreeText","codeValues","CodingSchemeDesignators","SRT","CornerstoneCodeSchemes","CodingSchemeDesignator","RELATIONSHIP_TYPE","INFERRED_FROM","CONTAINS","CORNERSTONE_FREETEXT_CODE_VALUE","addInstances","displaySetService","utils","instance","isLoaded","_getDisplaySetsFromSeries","servicesManager","extensionManager","SeriesInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","ConceptNameCodeSequence","SOPClassUID","CodeValue","services","uiNotificationService","show","title","message","type","duration","displaySet","Modality","referencedImages","measurements","isDerivedDisplaySet","load","measurementService","dataSources","getDataSources","dataSource","ContentSequence","ImagingMeasurementReportContentSequence","_getSequenceAsArray","find","item","ref","ReferencedSOPClassUID","_getReferencedImagesList","mergedContentSequencesByTrackingUniqueIdentifiers","MeasurementGroups","TrackingUniqueIdentifierItem","trackingUniqueIdentifier","UID","_getMergedContentSequencesByTrackingUniqueIdentifiers","mergedContentSequence","some","group","ValueType","graphicItem","UIDREFContentItem","TrackingIdentifierContentItem","NUMContentItems","_getCoordsFromSCOORDOrSCOORD3D","TextValue","MeasuredValueSequence","_getLabelFromMeasuredValueSequence","_processTID1410Measurement","finding","findingSites","ConceptCodeSequence","CodeMeaning","cornerstoneFreeTextFindingSite","_processNonGeometricallyDefinedMeasurement","_processMeasurement","_getMeasurements","mappings","getSourceMappings","isHydrated","isRehydratable","mappingDefinitions","m","annotationType","adapterKeys","adapterKey","isValidCornerstoneTrackingIdentifier","adapters","key","adapter","mappedTrackingIdentifier","log","activeDisplaySets","activeDisplaySet","_checkIfCanAddMeasurementsToDisplaySet","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","newDisplaySet","_load","srDisplaySet","unloadedMeasurements","images","SOPInstanceUIDs","imageIdsForDisplaySet","getImageIdsForDisplaySet","getUIDsFromImageID","j","_measurementReferencesSOPInstanceUID","splice","Number","RelationshipType","ReferencedFrameOfReferenceSequence","NumericValue","MeasurementUnitsCodeSequence","toFixed","sequence","Array","isArray","_ref","name","getDisplaySetsFromSeries","srProtocol","hasUpdatedPriorsInformation","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","srDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","viewports","OHIF","additionalFindingTypes","filteredToolState","addToFilteredToolState","toolType","imageIdSpecificToolState","measurementDataI","md","toolData","assign","uids","slice","framesOfReference","getFramesOfReference","frameOfReference","frameOfReferenceAnnotations","getAnnotations","toolTypes","k","uidIndex","findIndex","MeasurementReport","actions","downloadReport","_ref2","srDataset","generateReport","reportBlob","dcmjs","objectUrl","URL","createObjectURL","window","location","storeMeasurements","async","_ref3","info","store","dicom","error","Promise","reject","naturalizedReport","getFilteredCornerstoneToolState","report","dataset","SpecificCharacterSet","_generateReport","deleteStudyMetadataPromise","DicomMetadataStore","definitions","commandFn","storeContexts","defaultContext","addToolInstance","toolClass","InstanceClass","addTool","findInstance","sopUid","referencedDisplaySet","getDisplaySetByUID","findReferencedInstances","instanceById","createReferencedImageDisplaySet","imageSet","setAttributes","SeriesTime","isMultiFrame","numImageFrames","isReconstructable","isCompositeStack","madeInClient","excludeFromThumbnailBrowser","updateInstances","addDisplaySets","Component","React","OHIFCornerstoneSRViewport","props","fallback","onModeEnter","getDisplaySetCache","values","ds","preRegistration","LengthTool","BidirectionalTool","EllipticalROITool","CircleROITool","ArrowAnnotateTool","AngleTool","CobbAngleTool","PlanarFreehandROITool","dashedLine","global","getViewportModule","component","_extends","getCommandsModule","getSopClassHandlerModule","getUtilityModule","exports","state","trackingIdentifiersByViewportId","setTrackingUniqueIdentifiersForElement","getEnabledElement","guid","convertCode","codingValues","code","text","convertSites","sites","ret","site","hydrateStructuredReport","getActiveDataSource","customizationService","getCustomization","sopInstanceUIDToImageId","imageIdsForToolState","datasetToUse","REPORT","GROUP","TRACKING_IDENTIFIER","imagingMeasurementContent","toArray","codeMeaningEquals","measurementGroups","cornerstoneToolClasses","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","registeredToolClasses","measurementGroup","TrackingIdentifierGroup","contentItem","_mapLegacyDataSet","storedMeasurementByAnnotationType","generateToolState","hydratableMeasurementsInSR","imageIds","targetStudyInstanceUID","sopInstanceUid","SeriesInstanceUIDs","source","getSource","freeTextLabel","fs","getLabelFromDCMJSImportedToolData","matchingMapping","addRawMeasurement","toMeasurementSchema","codeMeaningName"],"sourceRoot":""}