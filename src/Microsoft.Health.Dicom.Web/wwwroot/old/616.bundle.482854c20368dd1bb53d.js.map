{"version":3,"file":"616.bundle.482854c20368dd1bb53d.js","mappings":"+LAEMA,E,6DAAKC,GAELC,EAAqB,GAAEF,oC,gDCG7B,MAAM,aAAEG,EAAY,oBAAEC,GAAwBC,EAAAA,QAAAA,KAExCC,EAAe,CAAC,gCAEtB,IAAIC,EAAe,CAAC,EAEpB,SAASC,EACPC,EACAC,EACAC,GAEA,MAAMC,EAAWH,EAAU,IAErB,iBACJI,EAAgB,kBAChBC,EAAiB,eACjBC,EAAc,kBACdC,EAAiB,aACjBC,EAAY,WACZC,EAAU,YACVC,EAAW,SACXC,EAAQ,QACRC,EAAO,YACPC,GACEV,EAEEW,EAAa,CACjBC,SAAU,MACVC,SAAS,EACTC,mBAAmB,EACnBC,sBAAuBC,EAAAA,QAAAA,OACvBZ,oBACAC,eACAC,aACAH,iBACAD,oBACAD,mBACAX,kBAAiB,EACjBiB,cACAU,iBAAkB,KAClBC,4BAA6B,KAC7BC,gCAAiC,KACjCC,qBAAqB,EACrBC,UAAU,EACVC,YAAY,EACZC,SAAU,CAAC,EACX7B,eACAM,WACAH,UAAW,CAACG,GACZQ,WACAE,cACAD,UACAe,qBAAqB,GAGjBC,EAA2BzB,EAAS0B,yBAE1C,IAAKD,EACH,MAAM,IAAIE,MAAM,mDAGlB,MAAMC,EAAmBH,EAAyB,GAgClD,OA9BAd,EAAWM,iBACTjB,EAAS0B,yBAAyBG,2BACpClB,EAAWO,4BAA8BU,EAAiB1B,kBAE1DS,EAAWmB,uBAAyB,KAClC,MAAM,kBAAEC,GAAsBjC,EAAgBkC,SACxCC,EAAwBF,EAAkBG,wBAC9CvB,EAAWO,6BAGb,IAAKe,GAA0D,IAAjCA,EAAsBE,OAClD,MAAM,IAAIR,MAAM,gDAGlB,MAAMS,EAAuBH,EAAsB,GAEnDtB,EAAWQ,gCACTiB,EAAqBrB,sBAGvBJ,EAAW0B,oBAAsBD,EAAqBrB,sBACtD,MAAMuB,EAAsB,mCAAkC3B,EAAW0B,sBAGzE,OAFA1B,EAAW2B,mBAAqBA,EAEzBF,CAAoB,EAG7BzB,EAAW4B,KAAOC,UAAA,IAAO,QAAEC,GAASC,EAAA,aAMtC,SAAeC,EAAe7C,EAAiBC,EAAkB0C,GAC/D,MAAM,eAAEtC,GAAmBwC,GACrB,oBAAEC,GAAwB9C,EAAgBkC,SAEhD,IACGW,EAAc9B,SAAW8B,EAActB,WACxC1B,EAAaQ,IAgEjB,SAA6BwC,EAAeC,GAE1C,OAAOA,EAAoBC,gBACzBF,EAAc5B,sBAElB,CApEI+B,CAAoBH,EAAeC,GAEnC,OAAOjD,EAAaQ,GAkCtB,OA/BAwC,EAAc9B,SAAU,EAIxBlB,EAAaQ,GAAkB,IAAI4C,SAAQP,MAAOQ,EAASC,KACzD,IACGN,EAAcpB,UACgC,IAA/C2B,OAAOC,KAAKR,EAAcpB,UAAUY,OACpC,CACA,MAAMZ,QAyBZiB,eAA6BzC,EAAkB4C,EAAeF,GAC5D,MAAMW,EAAgBrD,EAAiBsD,eACrC,qDAGI,mBAAEC,GAAuBF,EAAcG,QACvCC,QAAuBF,EAAmBG,qBAC9Cd,EACA,KACAF,GAGIiB,EAAYnE,EAAaoE,SAASH,GAClCI,EAAUpE,EAAoBqE,kBAAkBH,EAAUI,MAChEF,EAAQG,MAAQvE,EAAoBwE,cAAcN,EAAUO,MAEvDC,MAAMC,QAAQP,EAAQQ,mBACzBR,EAAQQ,gBAAkB,CAACR,EAAQQ,kBAGrC,MAAM7C,EAuFR,SAAsBqC,GACpB,MAAMrC,EAAW,CAAC,EA4BlB,OA1BAqC,EAAQQ,gBAAgBC,SAAQC,IAC9B,MAAMC,EAASD,EAAQE,8BACjBC,EAAOhF,EAAAA,QAAAA,KAAAA,OAAAA,aAA+B8E,GAAQG,KAAIC,GACtDC,KAAKC,MAAU,IAAJF,KAGbF,EAAKK,KAAK,KACV,MAAMC,EAAgBT,EAAQU,cAE9BzD,EAASwD,GAAiB,CACxBE,MAAOR,EACPS,iBAAkB,GAClBC,OAAQ,KACRC,KAAM,KACNC,UAAW,KACXC,MAAOhB,EAAQiB,aAChB,IAIH3B,EAAQ4B,iCAAiCnB,SAAQoB,IAC/C,MAAMV,EACJU,EAAgBC,8BAA8BC,wBAChDpE,EAASwD,GAAeG,iBAAiBJ,KAAKW,EAAgB,IAtGlE,SAAuB7B,EAASrC,GAC9B,IAAIqE,EAAYhB,KAAKiB,KAAMjC,EAAQkC,KAAOlC,EAAQmC,QAAW,GACzDC,EAAa,EAoBjB,OAlBA9C,OAAOC,KAAK5B,GAAU8C,SAAQ4B,IAC5B,MAAM3B,EAAU/C,EAAS0E,GACzB3B,EAAQ4B,eAAiB5B,EAAQY,iBAAiB/C,OAClDmC,EAAQc,KAAOd,EAAQ4B,eAAiBN,EACxCtB,EAAQa,OAASa,EACjBA,EAAa1B,EAAQa,OAASb,EAAQc,KACtC,MAAMe,EAAgBvC,EAAQwC,UAAU,GAAGC,MACzC/B,EAAQa,OACRa,GAGF1B,EAAQe,UAAY5F,EAAAA,QAAAA,KAAAA,SAAAA,OAA2B0G,GAC/C7B,EAAQgC,SASZ,SAAsC1C,EAAS2C,GAC7C,IAAIC,EACF5C,EAAQ6C,+BAA+BC,sBACrCC,EACF/C,EAAQ6C,+BAA+BG,yBACrCC,EAAgBN,EAAS,GAAGO,sBAEhC,MAAMR,EAAW,CAAC,EAIlB,IAAIS,EAAuBP,EAAcQ,qBACpCD,GACCP,EAAcS,iBAChBC,QAAQC,IAAI,gDACZJ,EAAuBP,EAAcS,gBAGzCX,EAASc,QAAU,CACjBZ,EAAca,aAAa,GAC3Bb,EAAca,aAAa,GAC3BN,GACArC,IAAI4C,QAENhB,EAASiB,WAAa,CAAC3D,EAAQmC,QAASnC,EAAQkC,KAAMS,EAASpE,QAAQuC,IACrE4C,QAGF,IAAIE,EAAcb,EAAiBc,wBAAwB/C,IAAI4C,QAC/D,MAAMI,EAAsBF,EAAYnB,MAAM,EAAG,GAC3CsB,EAAmBH,EAAYnB,MAAM,EAAG,GAC9CC,EAASsB,YAAc,GACvBC,EAAAA,GAAAA,MAAcH,EAAqBC,EAAkBrB,EAASsB,aAE9D,IAAIE,EAAgBvB,EAAS,GAAGO,sBAAsBiB,qBAAqBrD,IACzE4C,QAEEU,EAAezB,EACjBA,EAASpE,OAAS,GAClB2E,sBAAsBiB,qBAAqBrD,IAAI4C,QASjD,OARAhB,EAAS2B,UAAY,GACrBJ,EAAAA,GAAAA,SAAiBG,EAAcF,EAAexB,EAAS2B,WACvDJ,EAAAA,GAAAA,UAAkBvB,EAAS2B,WAC3B3B,EAAS4B,UAAYR,EAClBS,OAAOR,GACPQ,OAAO7B,EAAS2B,WACnB3B,EAAS8B,OAASvB,EAAckB,qBAAqBrD,IAAI4C,QAElDhB,CACT,CA1DuB+B,CACjBzE,EACAU,EAAQY,iBACT,IAGI3D,CACT,CAkFS+G,CAAc1E,EAASrC,EAChC,CArHmBgH,CAAa3E,GAC9B,OAAOrC,CACT,CA/C6BiH,CACrBzI,EACA4C,EACAF,GAGFE,EAAcpB,SAAWA,CAC3B,CAEA,MAAMkH,GAAiB,EACvB7F,EACG8F,mCAAmC/F,EAAe,KAAM8F,GACxDE,MAAK,KACJhG,EAAc9B,SAAU,EACxBmC,GAAS,IAEV4F,OAAMC,IACLlG,EAAc9B,SAAU,EACxBoC,EAAO4F,EAAM,GACb,IAGClJ,EAAaQ,EACtB,CAjDU2I,CAAMnI,EAAYb,EAAiBC,EAAkB0C,EAAQ,EAE9D,CAAC9B,EACV,CA6MA,QAlBA,SAAiCoI,GAAwC,IAAvC,gBAAEjJ,EAAe,iBAAEC,GAAkBgJ,EASrE,MAAO,CACL,CACEC,KAAM,YACNtJ,eACAuJ,yBAZ6BpJ,GACxBD,EACLC,EACAC,EACAC,IAWN,E,mCClPA,QA3DA,SAAyBmJ,EAAiB5D,EAAO6D,GAC/C,MAAMC,EAAW,sBAEXC,EAAkB3G,IAAuB,IAAtB,OAAE4G,EAAM,MAAEC,GAAO7G,EACxC,OAAQ4G,EAAOlK,IACb,IAAK,OACH+J,EAASI,EAAMjE,MAAOgE,EAAOlK,IAC7B,MACF,IAAK,SACH+J,EAAS,GAAIG,EAAOlK,IAGxB8J,EAAgBM,QAAQ,CAAEpK,GAAIgK,GAAW,EAGvCF,GACFA,EAAgBO,OAAO,CACrBrK,GAAIgK,EACJM,YAAY,EACZC,aAAa,EACbC,aAAa,EACbC,QAASC,EAAAA,GACTC,aAAc,CACZC,MAAO,sBACPT,MAAO,CAAEjE,SACT2E,eAAe,EACfC,QAASA,IAAMhB,EAAgBM,QAAQ,CAAEpK,GAAIgK,IAC7Ce,QAAS,CACP,CAAE/K,GAAI,SAAUgL,KAAM,SAAUC,KAAM,WACtC,CAAEjL,GAAI,OAAQgL,KAAM,UAAWC,KAAM,cAEvCC,SAAUjB,EACVkB,KAAMxB,IAAyB,IAAxB,MAAEQ,EAAK,SAAEiB,GAAUzB,EACxB,OACE0B,EAAAA,cAAA,OAAKC,UAAU,uBACbD,EAAAA,cAACE,EAAAA,GAAK,CACJC,WAAS,EACTF,UAAU,oCACVL,KAAK,OACLQ,mBAAmB,OACnBtB,MAAOA,EAAMjE,MACbwF,SAAUC,IACRA,EAAMC,UACNR,GAASjB,IAAS,IAAMA,EAAOjE,MAAOyF,EAAME,OAAO1B,SAAS,EAE9D2B,WAAYH,IACQ,UAAdA,EAAMI,KACR9B,EAAgB,CAAEE,QAAOD,OAAQ,CAAElK,GAAI,SACzC,IAGA,IAMlB,E,eCrDe,SAASgM,EAAiB1I,GAGtC,IAHuC,gBACxC5C,EAAe,gBACfuL,GACD3I,EACC,MAAM,oBAAEE,EAAmB,gBAAEsG,GAAoBpJ,EAAgBkC,UAE3D,EAAEsJ,IAAMC,EAAAA,EAAAA,IAAe,sBACtBC,EAAwBC,IAA6BC,EAAAA,EAAAA,UAAS,OAC9DC,EAA2BC,IAAgCF,EAAAA,EAAAA,UAChE9I,EAAoBiJ,qBAGfC,EAAeC,IAAoBL,EAAAA,EAAAA,WAAS,IACjD9I,EAAoBoJ,sBAGfC,EAAaC,IAAkBR,EAAAA,EAAAA,UAAS,CAAC,GAE1CS,GAA+BC,EAAAA,EAAAA,cACnChN,IACE8M,GAAeG,IAAa,IACvBA,EACH,CAACjN,IAAMiN,EAAUjN,MAChB,GAEL,CAAC8M,KAIHI,EAAAA,EAAAA,YAAU,KACR,MAAMC,EAAqBT,EAAcA,EAAc3J,OAAS,IAAI/C,GAChEmN,GACFL,GAAeG,IAAa,IACvBA,EACH,CAACE,IAAqB,KAE1B,GACC,CAACT,EAAeI,KAEnBI,EAAAA,EAAAA,YAAU,KAER,MAAME,EAAQ5J,EAAoB6J,OAAOC,mBACnCC,EAAU/J,EAAoB6J,OAAOG,qBACrCC,EAAUjK,EAAoB6J,OAAOK,qBACrCC,EAAgB,GAWtB,MATA,CAACP,EAAOG,EAASE,GAASxI,SAAQ2I,IAChC,MAAM,YAAEC,GAAgBrK,EAAoBsK,UAAUF,GAAK,KACzD,MAAMlB,EAAgBlJ,EAAoBoJ,mBAC1CD,EAAiBD,GACjBF,EAA6BhJ,EAAoBiJ,mBAAmB,IAEtEkB,EAAcjI,KAAKmI,EAAY,IAG1B,KACLF,EAAc1I,SAAQ8I,IACpBA,GAAO,GACP,CACH,GACA,IAEH,MAQMC,EAAkBC,GACDzK,EAAoB0K,gCACvCD,GAqGEE,GAAgCnB,EAAAA,EAAAA,cACpC,CAACiB,EAAgBlC,EAAK5B,KACpB3G,EAAoB4K,iBAAiB,CACnCH,iBACA,CAAClC,GAAM5B,GACP,GAEJ,CAAC3G,IAGH,OACE6H,EAAAA,cAAA,OAAKC,UAAU,wDAEZoB,GAAe3J,OACdsI,EAAAA,cAACgD,EAAAA,GAAsB,CACrBzD,MAAOsB,EAAE,iBACToC,qBAAqB,EACrB5B,cAAeA,EACfG,YAAaA,EACb0B,qBAAsBnC,GAA0B,GAChDoC,oBAnIqBP,IAC3BzK,EAAoBiL,kCAAkCR,EAAe,EAmI/DS,qBAhIsBT,IAC5BzK,EAAoBmL,OAAOV,EAAe,EAgIpCW,mBA5EmBX,IACzB,MAAMY,EAAerL,EAAoBC,gBAAgBwK,IACnD,MAAE/H,GAAU2I,EAElBC,EAAgBhF,EAAiB5D,GAAO,CAACA,EAAO6I,KAChC,KAAV7I,GAIJ1C,EAAoBwL,wBAClB,CACEhP,GAAIiO,EACJ/H,UAEF,GACA,EACD,GACD,EA4DI+I,eAtHeA,CAAChB,EAAgBiB,KACtC1L,EAAoB2L,gCAClBlB,EACAiB,GAGmBlB,EAAgBC,GAExBhJ,SAAQmK,IAEnB5L,EAAoBiL,kCAClBR,EACAmB,GAEF5L,EAAoB6L,oBAClBpB,EACAiB,EACAE,EACD,GACD,EAoGIE,cAjGcA,CAACrB,EAAgBiB,KACrC,MAEMhK,EAFe1B,EAAoBC,gBAAgBwK,GAE5B9L,SAAS+M,IAChC,MAAEhJ,GAAUhB,EAElB4J,EAAgBhF,EAAiB5D,GAAO,CAACA,EAAO6I,KAChC,KAAV7I,GAIJ1C,EAAoB+L,+BAClBtB,EACAiB,EACAhJ,EACD,GACD,EAkFIsJ,oBA3DoBA,CAACvB,EAAgBiB,KAErC,EA0DAO,gBAvDgBA,CAACxB,EAAgBiB,KAKvCpH,QAAQ4H,KAAK,sBAAsB,EAmD7BC,0BAhD0BA,CAAC1B,EAAgBiB,KACjD,MAEMU,GAFepM,EAAoBC,gBAAgBwK,GACxB9L,SAAS+M,GACXU,UACV5B,EAAgBC,GAGxBhJ,SAAQmK,IACnB5L,EAAoBqM,qBAClB5B,EACAiB,EACAU,EACAR,EACD,GACD,EAmCIU,+BAhC+B7B,IACrCzK,EAAoBuM,6BAA6B9B,EAAe,EAgC1DlB,6BAA8BA,EAC9BiD,mBAAoB,CAAEC,cAAe1D,GACrC2D,iBAAkB/F,GAChBgE,EACE/B,EACA,gBACAjC,GAGJgG,wBAAyBhG,GACvBgE,EACE/B,EACA,iBACAjC,GAGJiG,cAAejG,GACbgE,EACE/B,EACA,aACAjC,GAGJkG,+BAAgClG,GAC9BgE,EACE/B,EACA,8BACAjC,GAGJmG,sBAAuBnG,GACrBgE,EACE/B,EACA,qBACAjC,GAGJoG,aAAcpG,GACZgE,EACE/B,EACA,YACAjC,GAGJqG,qBAAsBrG,GACpBgE,EACE/B,EACA,oBACAjC,KAIJ,KAGV,CAEA6B,EAAkByE,UAAY,CAC5BxE,gBAAiByE,IAAAA,MAAgB,CAC/BC,WAAYD,IAAAA,KAAAA,aAEdhQ,gBAAiBgQ,IAAAA,MAAgB,CAC/B9N,SAAU8N,IAAAA,MAAgB,CACxBlN,oBAAqBkN,IAAAA,MAAgB,CACnCjN,gBAAiBiN,IAAAA,KAAAA,WACjB9D,iBAAkB8D,IAAAA,KAAAA,WAClBX,6BAA8BW,IAAAA,KAAAA,WAC9B5C,UAAW4C,IAAAA,KAAAA,WACXrD,OAAQqD,IAAAA,OAAAA,aACPE,aACFA,aACFA,YCtRL,MAAMC,EAA8C,CAClD7Q,GAAI,YAIJ8Q,6BAA6B,EAC7BlH,KAAM,gBAENmH,sBAAuB,GACvBC,aAAc,CAAC,WAIfC,yBAA0B,EAG1BC,gBAAiB,CACfC,gBAAiB,CACfC,aAAc,QACdhC,YAAa,UACbiC,oBAAoB,GAEtBC,YAAa,CACX,CACEtR,GAAI,kBACJuR,yBAA0B,KAIhCC,oBAAqB,CACnBC,gBAAiB,CACfC,oBAAqB,CACnB,CACEC,UAAW,WACXC,WAAY,CACVC,OAAQ,WAMlBC,OAAQ,CACN,CACElI,KAAM,gBACNmI,kBAAmB,CACjBC,WAAY,OACZC,WAAY,CACVC,KAAM,EACNC,QAAS,IAGbC,UAAW,CACT,CACEjB,gBAAiB,CAAEE,oBAAoB,GACvCC,YAAa,CACX,CACEtR,GAAI,yBAkBlB,QATA,WACE,MAAO,CACL,CACE4J,KAAMiH,EAAY7Q,GAClBqS,SAAUxB,GAGhB,E,oOC/DA,MAAMyB,EAAYjH,EAAAA,MAAW,IACpB,iCAKHkH,EAA6BC,GAE/BnH,EAAAA,cAACA,EAAAA,SAAc,CAACoH,SAAUpH,EAAAA,cAAA,WAAK,eAC7BA,EAAAA,cAACiH,EAAcE,IAwErB,EAhEkB,CAKhBxS,GAAE,EAQF0S,eAAgBpP,IAIK,IAJJ,gBACf5C,EAAe,gBACfuL,EAAe,iBACftL,GACD2C,EAWC,MAAO,CACL,CACEsG,KAAM,oBACN+I,SAAU,mBACVC,UAAW,eACX1M,MAAO,eACP2M,UAhB6BC,IAE7BzH,EAAAA,cAACW,EAAiB,CAChBC,gBAAiBA,EACjBvL,gBAAiBA,EACjBC,iBAAkBA,KAavB,EAGHoS,kBAAiBpJ,GAAwC,IAAvC,gBAAEjJ,EAAe,iBAAEC,GAAkBgJ,EAWrD,MAAO,CACL,CAAEC,KAAM,YAAaiJ,UAXoBL,GAEvCnH,EAAAA,cAACkH,EAA0BS,EAAA,CACzBtS,gBAAiBA,EACjBC,iBAAkBA,GACd6R,KAQZ,EAOAS,yBAAwB,EACxBC,yBAAwBA,E","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/callInputDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/PanelSegmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx"],"sourcesContent":["import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\nconst SOPClassHandlerName = 'dicom-seg';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\r\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\r\n\r\nimport { utils } from '@ohif/core';\r\n\r\nimport { SOPClassHandlerId } from './id';\r\nimport dcmjs from 'dcmjs';\r\n\r\nconst { DicomMessage, DicomMetaDictionary } = dcmjs.data;\r\n\r\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\r\n\r\nlet loadPromises = {};\r\n\r\nfunction _getDisplaySetsFromSeries(\r\n  instances,\r\n  servicesManager,\r\n  extensionManager\r\n) {\r\n  const instance = instances[0];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPClassUID,\r\n    wadoRoot,\r\n    wadoUri,\r\n    wadoUriRoot,\r\n  } = instance;\r\n\r\n  const displaySet = {\r\n    Modality: 'SEG',\r\n    loading: false,\r\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId,\r\n    SOPClassUID,\r\n    referencedImages: null,\r\n    referencedSeriesInstanceUID: null,\r\n    referencedDisplaySetInstanceUID: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    isHydrated: false,\r\n    segments: {},\r\n    sopClassUids,\r\n    instance,\r\n    instances: [instance],\r\n    wadoRoot,\r\n    wadoUriRoot,\r\n    wadoUri,\r\n    isOverlayDisplaySet: true,\r\n  };\r\n\r\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\r\n\r\n  if (!referencedSeriesSequence) {\r\n    throw new Error('ReferencedSeriesSequence is missing for the SEG');\r\n  }\r\n\r\n  const referencedSeries = referencedSeriesSequence[0];\r\n\r\n  displaySet.referencedImages =\r\n    instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\r\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\r\n\r\n  displaySet.getReferenceDisplaySet = () => {\r\n    const { displaySetService } = servicesManager.services;\r\n    const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\r\n      displaySet.referencedSeriesInstanceUID\r\n    );\r\n\r\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\r\n      throw new Error('Referenced DisplaySet is missing for the SEG');\r\n    }\r\n\r\n    const referencedDisplaySet = referencedDisplaySets[0];\r\n\r\n    displaySet.referencedDisplaySetInstanceUID =\r\n      referencedDisplaySet.displaySetInstanceUID;\r\n\r\n    // Todo: this needs to be able to work with other reference volumes (other than streaming) such as nifti, etc.\r\n    displaySet.referencedVolumeURI = referencedDisplaySet.displaySetInstanceUID;\r\n    const referencedVolumeId = `cornerstoneStreamingImageVolume:${displaySet.referencedVolumeURI}`;\r\n    displaySet.referencedVolumeId = referencedVolumeId;\r\n\r\n    return referencedDisplaySet;\r\n  };\r\n\r\n  displaySet.load = async ({ headers }) =>\r\n    await _load(displaySet, servicesManager, extensionManager, headers);\r\n\r\n  return [displaySet];\r\n}\r\n\r\nfunction _load(segDisplaySet, servicesManager, extensionManager, headers) {\r\n  const { SOPInstanceUID } = segDisplaySet;\r\n  const { segmentationService } = servicesManager.services;\r\n\r\n  if (\r\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\r\n    loadPromises[SOPInstanceUID] &&\r\n    _segmentationExists(segDisplaySet, segmentationService)\r\n  ) {\r\n    return loadPromises[SOPInstanceUID];\r\n  }\r\n\r\n  segDisplaySet.loading = true;\r\n\r\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\r\n  // and also return the same promise to any other callers.\r\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\r\n    if (\r\n      !segDisplaySet.segments ||\r\n      Object.keys(segDisplaySet.segments).length === 0\r\n    ) {\r\n      const segments = await _loadSegments(\r\n        extensionManager,\r\n        segDisplaySet,\r\n        headers\r\n      );\r\n\r\n      segDisplaySet.segments = segments;\r\n    }\r\n\r\n    const suppressEvents = true;\r\n    segmentationService\r\n      .createSegmentationForSEGDisplaySet(segDisplaySet, null, suppressEvents)\r\n      .then(() => {\r\n        segDisplaySet.loading = false;\r\n        resolve();\r\n      })\r\n      .catch(error => {\r\n        segDisplaySet.loading = false;\r\n        reject(error);\r\n      });\r\n  });\r\n\r\n  return loadPromises[SOPInstanceUID];\r\n}\r\n\r\nasync function _loadSegments(extensionManager, segDisplaySet, headers) {\r\n  const utilityModule = extensionManager.getModuleEntry(\r\n    '@ohif/extension-cornerstone.utilityModule.common'\r\n  );\r\n\r\n  const { dicomLoaderService } = utilityModule.exports;\r\n  const segArrayBuffer = await dicomLoaderService.findDicomDataPromise(\r\n    segDisplaySet,\r\n    null,\r\n    headers\r\n  );\r\n\r\n  const dicomData = DicomMessage.readFile(segArrayBuffer);\r\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\r\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n\r\n  if (!Array.isArray(dataset.SegmentSequence)) {\r\n    dataset.SegmentSequence = [dataset.SegmentSequence];\r\n  }\r\n\r\n  const segments = _getSegments(dataset);\r\n  return segments;\r\n}\r\n\r\nfunction _segmentationExists(segDisplaySet, segmentationService) {\r\n  // This should be abstracted with the CornerstoneCacheService\r\n  return segmentationService.getSegmentation(\r\n    segDisplaySet.displaySetInstanceUID\r\n  );\r\n}\r\n\r\nfunction _getPixelData(dataset, segments) {\r\n  let frameSize = Math.ceil((dataset.Rows * dataset.Columns) / 8);\r\n  let nextOffset = 0;\r\n\r\n  Object.keys(segments).forEach(segmentKey => {\r\n    const segment = segments[segmentKey];\r\n    segment.numberOfFrames = segment.functionalGroups.length;\r\n    segment.size = segment.numberOfFrames * frameSize;\r\n    segment.offset = nextOffset;\r\n    nextOffset = segment.offset + segment.size;\r\n    const packedSegment = dataset.PixelData[0].slice(\r\n      segment.offset,\r\n      nextOffset\r\n    );\r\n\r\n    segment.pixelData = dcmjs.data.BitArray.unpack(packedSegment);\r\n    segment.geometry = geometryFromFunctionalGroups(\r\n      dataset,\r\n      segment.functionalGroups\r\n    );\r\n  });\r\n\r\n  return segments;\r\n}\r\n\r\nfunction geometryFromFunctionalGroups(dataset, perFrame) {\r\n  let pixelMeasures =\r\n    dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\r\n  let planeOrientation =\r\n    dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\r\n  let planePosition = perFrame[0].PlanePositionSequence; // TODO: assume sorted frames!\r\n\r\n  const geometry = {};\r\n\r\n  // NB: DICOM PixelSpacing is defined as Row then Column,\r\n  // unlike ImageOrientationPatient\r\n  let spacingBetweenSlices = pixelMeasures.SpacingBetweenSlices;\r\n  if (!spacingBetweenSlices) {\r\n    if (pixelMeasures.SliceThickness) {\r\n      console.log('Using SliceThickness as SpacingBetweenSlices');\r\n      spacingBetweenSlices = pixelMeasures.SliceThickness;\r\n    }\r\n  }\r\n  geometry.spacing = [\r\n    pixelMeasures.PixelSpacing[1],\r\n    pixelMeasures.PixelSpacing[0],\r\n    spacingBetweenSlices,\r\n  ].map(Number);\r\n\r\n  geometry.dimensions = [dataset.Columns, dataset.Rows, perFrame.length].map(\r\n    Number\r\n  );\r\n\r\n  let orientation = planeOrientation.ImageOrientationPatient.map(Number);\r\n  const columnStepToPatient = orientation.slice(0, 3);\r\n  const rowStepToPatient = orientation.slice(3, 6);\r\n  geometry.planeNormal = [];\r\n  vtkMath.cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\r\n\r\n  let firstPosition = perFrame[0].PlanePositionSequence.ImagePositionPatient.map(\r\n    Number\r\n  );\r\n  let lastPosition = perFrame[\r\n    perFrame.length - 1\r\n  ].PlanePositionSequence.ImagePositionPatient.map(Number);\r\n  geometry.sliceStep = [];\r\n  vtkMath.subtract(lastPosition, firstPosition, geometry.sliceStep);\r\n  vtkMath.normalize(geometry.sliceStep);\r\n  geometry.direction = columnStepToPatient\r\n    .concat(rowStepToPatient)\r\n    .concat(geometry.sliceStep);\r\n  geometry.origin = planePosition.ImagePositionPatient.map(Number);\r\n\r\n  return geometry;\r\n}\r\n\r\nfunction _getSegments(dataset) {\r\n  const segments = {};\r\n\r\n  dataset.SegmentSequence.forEach(segment => {\r\n    const cielab = segment.RecommendedDisplayCIELabValue;\r\n    const rgba = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x =>\r\n      Math.round(x * 255)\r\n    );\r\n\r\n    rgba.push(255);\r\n    const segmentNumber = segment.SegmentNumber;\r\n\r\n    segments[segmentNumber] = {\r\n      color: rgba,\r\n      functionalGroups: [],\r\n      offset: null,\r\n      size: null,\r\n      pixelData: null,\r\n      label: segment.SegmentLabel,\r\n    };\r\n  });\r\n\r\n  // make a list of functional groups per segment\r\n  dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\r\n    const segmentNumber =\r\n      functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\r\n    segments[segmentNumber].functionalGroups.push(functionalGroup);\r\n  });\r\n\r\n  return _getPixelData(dataset, segments);\r\n}\r\n\r\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\r\n  const getDisplaySetsFromSeries = instances => {\r\n    return _getDisplaySetsFromSeries(\r\n      instances,\r\n      servicesManager,\r\n      extensionManager\r\n    );\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: 'dicom-seg',\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import React from 'react';\r\nimport { Input, Dialog } from '@ohif/ui';\r\n\r\nfunction callInputDialog(uiDialogService, label, callback) {\r\n  const dialogId = 'enter-segment-label';\r\n\r\n  const onSubmitHandler = ({ action, value }) => {\r\n    switch (action.id) {\r\n      case 'save':\r\n        callback(value.label, action.id);\r\n        break;\r\n      case 'cancel':\r\n        callback('', action.id);\r\n        break;\r\n    }\r\n    uiDialogService.dismiss({ id: dialogId });\r\n  };\r\n\r\n  if (uiDialogService) {\r\n    uiDialogService.create({\r\n      id: dialogId,\r\n      centralize: true,\r\n      isDraggable: false,\r\n      showOverlay: true,\r\n      content: Dialog,\r\n      contentProps: {\r\n        title: 'Enter Segment Label',\r\n        value: { label },\r\n        noCloseButton: true,\r\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\r\n        actions: [\r\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\r\n          { id: 'save', text: 'Confirm', type: 'secondary' },\r\n        ],\r\n        onSubmit: onSubmitHandler,\r\n        body: ({ value, setValue }) => {\r\n          return (\r\n            <div className=\"p-4 bg-primary-dark\">\r\n              <Input\r\n                autoFocus\r\n                className=\"mt-2 bg-black border-primary-main\"\r\n                type=\"text\"\r\n                containerClassName=\"mr-2\"\r\n                value={value.label}\r\n                onChange={event => {\r\n                  event.persist();\r\n                  setValue(value => ({ ...value, label: event.target.value }));\r\n                }}\r\n                onKeyPress={event => {\r\n                  if (event.key === 'Enter') {\r\n                    onSubmitHandler({ value, action: { id: 'save' } });\r\n                  }\r\n                }}\r\n              />\r\n            </div>\r\n          );\r\n        },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default callInputDialog;\r\n","import React, { useEffect, useState, useCallback } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { SegmentationGroupTable } from '@ohif/ui';\r\nimport callInputDialog from './callInputDialog';\r\n\r\nimport { useTranslation } from 'react-i18next';\r\n\r\nexport default function PanelSegmentation({\r\n  servicesManager,\r\n  commandsManager,\r\n}) {\r\n  const { segmentationService, uiDialogService } = servicesManager.services;\r\n\r\n  const { t } = useTranslation('PanelSegmentation');\r\n  const [selectedSegmentationId, setSelectedSegmentationId] = useState(null);\r\n  const [segmentationConfiguration, setSegmentationConfiguration] = useState(\r\n    segmentationService.getConfiguration()\r\n  );\r\n\r\n  const [segmentations, setSegmentations] = useState(() =>\r\n    segmentationService.getSegmentations()\r\n  );\r\n\r\n  const [isMinimized, setIsMinimized] = useState({});\r\n\r\n  const onToggleMinimizeSegmentation = useCallback(\r\n    id => {\r\n      setIsMinimized(prevState => ({\r\n        ...prevState,\r\n        [id]: !prevState[id],\r\n      }));\r\n    },\r\n    [setIsMinimized]\r\n  );\r\n\r\n  // Only expand the last segmentation added to the list and collapse the rest\r\n  useEffect(() => {\r\n    const lastSegmentationId = segmentations[segmentations.length - 1]?.id;\r\n    if (lastSegmentationId) {\r\n      setIsMinimized(prevState => ({\r\n        ...prevState,\r\n        [lastSegmentationId]: false,\r\n      }));\r\n    }\r\n  }, [segmentations, setIsMinimized]);\r\n\r\n  useEffect(() => {\r\n    // ~~ Subscription\r\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\r\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\r\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\r\n    const subscriptions = [];\r\n\r\n    [added, updated, removed].forEach(evt => {\r\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\r\n        const segmentations = segmentationService.getSegmentations();\r\n        setSegmentations(segmentations);\r\n        setSegmentationConfiguration(segmentationService.getConfiguration());\r\n      });\r\n      subscriptions.push(unsubscribe);\r\n    });\r\n\r\n    return () => {\r\n      subscriptions.forEach(unsub => {\r\n        unsub();\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  const onSegmentationClick = (segmentationId: string) => {\r\n    segmentationService.setActiveSegmentationForToolGroup(segmentationId);\r\n  };\r\n\r\n  const onSegmentationDelete = (segmentationId: string) => {\r\n    segmentationService.remove(segmentationId);\r\n  };\r\n\r\n  const getToolGroupIds = segmentationId => {\r\n    const toolGroupIds = segmentationService.getToolGroupIdsWithSegmentation(\r\n      segmentationId\r\n    );\r\n\r\n    return toolGroupIds;\r\n  };\r\n\r\n  const onSegmentClick = (segmentationId, segmentIndex) => {\r\n    segmentationService.setActiveSegmentForSegmentation(\r\n      segmentationId,\r\n      segmentIndex\r\n    );\r\n\r\n    const toolGroupIds = getToolGroupIds(segmentationId);\r\n\r\n    toolGroupIds.forEach(toolGroupId => {\r\n      // const toolGroupId =\r\n      segmentationService.setActiveSegmentationForToolGroup(\r\n        segmentationId,\r\n        toolGroupId\r\n      );\r\n      segmentationService.jumpToSegmentCenter(\r\n        segmentationId,\r\n        segmentIndex,\r\n        toolGroupId\r\n      );\r\n    });\r\n  };\r\n\r\n  const onSegmentEdit = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n    const segment = segmentation.segments[segmentIndex];\r\n    const { label } = segment;\r\n\r\n    callInputDialog(uiDialogService, label, (label, actionId) => {\r\n      if (label === '') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.setSegmentLabelForSegmentation(\r\n        segmentationId,\r\n        segmentIndex,\r\n        label\r\n      );\r\n    });\r\n  };\r\n\r\n  const onSegmentationEdit = segmentationId => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n    const { label } = segmentation;\r\n\r\n    callInputDialog(uiDialogService, label, (label, actionId) => {\r\n      if (label === '') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.addOrUpdateSegmentation(\r\n        {\r\n          id: segmentationId,\r\n          label,\r\n        },\r\n        false, // suppress event\r\n        true // notYetUpdatedAtSource\r\n      );\r\n    });\r\n  };\r\n\r\n  const onSegmentColorClick = (segmentationId, segmentIndex) => {\r\n    // Todo: Implement color picker later\r\n    return;\r\n  };\r\n\r\n  const onSegmentDelete = (segmentationId, segmentIndex) => {\r\n    // segmentationService.removeSegmentFromSegmentation(\r\n    //   segmentationId,\r\n    //   segmentIndex\r\n    // );\r\n    console.warn('not implemented yet');\r\n  };\r\n\r\n  const onToggleSegmentVisibility = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n    const segmentInfo = segmentation.segments[segmentIndex];\r\n    const isVisible = !segmentInfo.isVisible;\r\n    const toolGroupIds = getToolGroupIds(segmentationId);\r\n\r\n    // Todo: right now we apply the visibility to all tool groups\r\n    toolGroupIds.forEach(toolGroupId => {\r\n      segmentationService.setSegmentVisibility(\r\n        segmentationId,\r\n        segmentIndex,\r\n        isVisible,\r\n        toolGroupId\r\n      );\r\n    });\r\n  };\r\n\r\n  const onToggleSegmentationVisibility = segmentationId => {\r\n    segmentationService.toggleSegmentationVisibility(segmentationId);\r\n  };\r\n\r\n  const _setSegmentationConfiguration = useCallback(\r\n    (segmentationId, key, value) => {\r\n      segmentationService.setConfiguration({\r\n        segmentationId,\r\n        [key]: value,\r\n      });\r\n    },\r\n    [segmentationService]\r\n  );\r\n\r\n  return (\r\n    <div className=\"flex flex-col flex-auto min-h-0 justify-between mt-1\">\r\n      {/* show segmentation table */}\r\n      {segmentations?.length ? (\r\n        <SegmentationGroupTable\r\n          title={t('Segmentations')}\r\n          showAddSegmentation={false}\r\n          segmentations={segmentations}\r\n          isMinimized={isMinimized}\r\n          activeSegmentationId={selectedSegmentationId || ''}\r\n          onSegmentationClick={onSegmentationClick}\r\n          onSegmentationDelete={onSegmentationDelete}\r\n          onSegmentationEdit={onSegmentationEdit}\r\n          onSegmentClick={onSegmentClick}\r\n          onSegmentEdit={onSegmentEdit}\r\n          onSegmentColorClick={onSegmentColorClick}\r\n          onSegmentDelete={onSegmentDelete}\r\n          onToggleSegmentVisibility={onToggleSegmentVisibility}\r\n          onToggleSegmentationVisibility={onToggleSegmentationVisibility}\r\n          onToggleMinimizeSegmentation={onToggleMinimizeSegmentation}\r\n          segmentationConfig={{ initialConfig: segmentationConfiguration }}\r\n          setRenderOutline={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'renderOutline',\r\n              value\r\n            )\r\n          }\r\n          setOutlineOpacityActive={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'outlineOpacity',\r\n              value\r\n            )\r\n          }\r\n          setRenderFill={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'renderFill',\r\n              value\r\n            )\r\n          }\r\n          setRenderInactiveSegmentations={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'renderInactiveSegmentations',\r\n              value\r\n            )\r\n          }\r\n          setOutlineWidthActive={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'outlineWidthActive',\r\n              value\r\n            )\r\n          }\r\n          setFillAlpha={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'fillAlpha',\r\n              value\r\n            )\r\n          }\r\n          setFillAlphaInactive={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'fillAlphaInactive',\r\n              value\r\n            )\r\n          }\r\n        />\r\n      ) : null}\r\n    </div>\r\n  );\r\n}\r\n\r\nPanelSegmentation.propTypes = {\r\n  commandsManager: PropTypes.shape({\r\n    runCommand: PropTypes.func.isRequired,\r\n  }),\r\n  servicesManager: PropTypes.shape({\r\n    services: PropTypes.shape({\r\n      segmentationService: PropTypes.shape({\r\n        getSegmentation: PropTypes.func.isRequired,\r\n        getSegmentations: PropTypes.func.isRequired,\r\n        toggleSegmentationVisibility: PropTypes.func.isRequired,\r\n        subscribe: PropTypes.func.isRequired,\r\n        EVENTS: PropTypes.object.isRequired,\r\n      }).isRequired,\r\n    }).isRequired,\r\n  }).isRequired,\r\n};\r\n","import { Types } from '@ohif/core';\r\n\r\nconst segProtocol: Types.HangingProtocol.Protocol = {\r\n  id: '@ohif/seg',\r\n  // Don't store this hanging protocol as it applies to the currently active\r\n  // display set by default\r\n  // cacheId: null,\r\n  hasUpdatedPriorsInformation: false,\r\n  name: 'Segmentations',\r\n  // Just apply this one when specifically listed\r\n  protocolMatchingRules: [],\r\n  toolGroupIds: ['default'],\r\n  // -1 would be used to indicate active only, whereas other values are\r\n  // the number of required priors referenced - so 0 means active with\r\n  // 0 or more priors.\r\n  numberOfPriorsReferenced: 0,\r\n  // Default viewport is used to define the viewport when\r\n  // additional viewports are added using the layout tool\r\n  defaultViewport: {\r\n    viewportOptions: {\r\n      viewportType: 'stack',\r\n      toolGroupId: 'default',\r\n      allowUnmatchedView: true,\r\n    },\r\n    displaySets: [\r\n      {\r\n        id: 'segDisplaySetId',\r\n        matchedDisplaySetsIndex: -1,\r\n      },\r\n    ],\r\n  },\r\n  displaySetSelectors: {\r\n    segDisplaySetId: {\r\n      seriesMatchingRules: [\r\n        {\r\n          attribute: 'Modality',\r\n          constraint: {\r\n            equals: 'SEG',\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  stages: [\r\n    {\r\n      name: 'Segmentations',\r\n      viewportStructure: {\r\n        layoutType: 'grid',\r\n        properties: {\r\n          rows: 1,\r\n          columns: 1,\r\n        },\r\n      },\r\n      viewports: [\r\n        {\r\n          viewportOptions: { allowUnmatchedView: true },\r\n          displaySets: [\r\n            {\r\n              id: 'segDisplaySetId',\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\nfunction getHangingProtocolModule() {\r\n  return [\r\n    {\r\n      name: segProtocol.id,\r\n      protocol: segProtocol,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getHangingProtocolModule;\r\nexport { segProtocol };\r\n","import { id } from './id';\r\nimport React from 'react';\r\n\r\nimport { Types } from '@ohif/core';\r\n\r\nimport getSopClassHandlerModule, {\r\n  protocols,\r\n} from './getSopClassHandlerModule';\r\nimport PanelSegmentation from './panels/PanelSegmentation';\r\nimport getHangingProtocolModule from './getHangingProtocolModule';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(\r\n    /* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport'\r\n  );\r\n});\r\n\r\nconst OHIFCornerstoneSEGViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n * You can remove any of the following modules if you don't need them.\r\n */\r\nconst extension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   * You ID can be anything you want, but it should be unique.\r\n   */\r\n  id,\r\n\r\n  /**\r\n   * PanelModule should provide a list of panels that will be available in OHIF\r\n   * for Modes to consume and render. Each panel is defined by a {name,\r\n   * iconName, iconLabel, label, component} object. Example of a panel module\r\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\r\n   */\r\n  getPanelModule: ({\r\n    servicesManager,\r\n    commandsManager,\r\n    extensionManager,\r\n  }): Types.Panel[] => {\r\n    const wrappedPanelSegmentation = () => {\r\n      return (\r\n        <PanelSegmentation\r\n          commandsManager={commandsManager}\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [\r\n      {\r\n        name: 'panelSegmentation',\r\n        iconName: 'tab-segmentation',\r\n        iconLabel: 'Segmentation',\r\n        label: 'Segmentation',\r\n        component: wrappedPanelSegmentation,\r\n      },\r\n    ];\r\n  },\r\n\r\n  getViewportModule({ servicesManager, extensionManager }) {\r\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneSEGViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [\r\n      { name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport },\r\n    ];\r\n  },\r\n  /**\r\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\r\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\r\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\r\n   * Examples include the default sop class handler provided by the default extension\r\n   */\r\n  getSopClassHandlerModule,\r\n  getHangingProtocolModule,\r\n};\r\n\r\nexport default extension;\r\n\r\n// Export the protocols separately to allow for extending it at compile time\r\n// in other modules\r\nexport { protocols };\r\n"],"names":["id","packageJson","SOPClassHandlerId","DicomMessage","DicomMetaDictionary","dcmjs","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","Error","referencedSeries","ReferencedInstanceSequence","getReferenceDisplaySet","displaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","length","referencedDisplaySet","referencedVolumeURI","referencedVolumeId","load","async","headers","_ref","segDisplaySet","segmentationService","getSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","utilityModule","getModuleEntry","dicomLoaderService","exports","segArrayBuffer","findDicomDataPromise","dicomData","readFile","dataset","naturalizeDataset","dict","_meta","namifyDataset","meta","Array","isArray","SegmentSequence","forEach","segment","cielab","RecommendedDisplayCIELabValue","rgba","map","x","Math","round","push","segmentNumber","SegmentNumber","color","functionalGroups","offset","size","pixelData","label","SegmentLabel","PerFrameFunctionalGroupsSequence","functionalGroup","SegmentIdentificationSequence","ReferencedSegmentNumber","frameSize","ceil","Rows","Columns","nextOffset","segmentKey","numberOfFrames","packedSegment","PixelData","slice","geometry","perFrame","pixelMeasures","SharedFunctionalGroupsSequence","PixelMeasuresSequence","planeOrientation","PlaneOrientationSequence","planePosition","PlanePositionSequence","spacingBetweenSlices","SpacingBetweenSlices","SliceThickness","console","log","spacing","PixelSpacing","Number","dimensions","orientation","ImageOrientationPatient","columnStepToPatient","rowStepToPatient","planeNormal","vtkMath","firstPosition","ImagePositionPatient","lastPosition","sliceStep","direction","concat","origin","geometryFromFunctionalGroups","_getPixelData","_getSegments","_loadSegments","suppressEvents","createSegmentationForSEGDisplaySet","then","catch","error","_load","_ref2","name","getDisplaySetsFromSeries","uiDialogService","callback","dialogId","onSubmitHandler","action","value","dismiss","create","centralize","isDraggable","showOverlay","content","Dialog","contentProps","title","noCloseButton","onClose","actions","text","type","onSubmit","body","setValue","React","className","Input","autoFocus","containerClassName","onChange","event","persist","target","onKeyPress","key","PanelSegmentation","commandsManager","t","useTranslation","selectedSegmentationId","setSelectedSegmentationId","useState","segmentationConfiguration","setSegmentationConfiguration","getConfiguration","segmentations","setSegmentations","getSegmentations","isMinimized","setIsMinimized","onToggleMinimizeSegmentation","useCallback","prevState","useEffect","lastSegmentationId","added","EVENTS","SEGMENTATION_ADDED","updated","SEGMENTATION_UPDATED","removed","SEGMENTATION_REMOVED","subscriptions","evt","unsubscribe","subscribe","unsub","getToolGroupIds","segmentationId","getToolGroupIdsWithSegmentation","_setSegmentationConfiguration","setConfiguration","SegmentationGroupTable","showAddSegmentation","activeSegmentationId","onSegmentationClick","setActiveSegmentationForToolGroup","onSegmentationDelete","remove","onSegmentationEdit","segmentation","callInputDialog","actionId","addOrUpdateSegmentation","onSegmentClick","segmentIndex","setActiveSegmentForSegmentation","toolGroupId","jumpToSegmentCenter","onSegmentEdit","setSegmentLabelForSegmentation","onSegmentColorClick","onSegmentDelete","warn","onToggleSegmentVisibility","isVisible","setSegmentVisibility","onToggleSegmentationVisibility","toggleSegmentationVisibility","segmentationConfig","initialConfig","setRenderOutline","setOutlineOpacityActive","setRenderFill","setRenderInactiveSegmentations","setOutlineWidthActive","setFillAlpha","setFillAlphaInactive","propTypes","PropTypes","runCommand","isRequired","segProtocol","hasUpdatedPriorsInformation","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","Component","OHIFCornerstoneSEGViewport","props","fallback","getPanelModule","iconName","iconLabel","component","wrappedPanelSegmentation","getViewportModule","_extends","getSopClassHandlerModule","getHangingProtocolModule"],"sourceRoot":""}